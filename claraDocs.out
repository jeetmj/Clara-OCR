#line book.c:33 (tutorial)
>/* (tutorial)
>
>NAME
>----
>
>clara - a cooperative OCR
>
>SYNOPSIS
>--------
>
>clara [options]
>
>
>DESCRIPTION
>-----------
>
>Welcome. Clara OCR is a free OCR, written for systems supporting
>the C library and the X Windows System. Clara OCR is intended for the
>cooperative OCR of books. There are some screenshots available at
>CLARA_HOME.
>
>This documentation is extracted automatically from the comments
>of the Clara OCR source code. It is known as "The Clara OCR
>Tutorial". There is also an advanced manual known as "The Clara
>OCR Advanced User's Manual" (man page clara-adv(1), also
>available in HTML format). Developers must read "The Clara OCR
>Developer's Guide" (man page clara-dev(1), also available in HTML
>format).
>
>CONTENTS
>--------
>
>Making OCR
>
>    Starting Clara
>    Some few command-line switches
>    Training symbols
>    Saving the session
>    OCR steps
>    Classification
>    Note about how Clara OCR classification works
>    Building the output
>    Handling broken symbols
>    Handling accents
>    Browsing the book font
>    Useful hints
>    Fun codes
>
>AVAILABILITY
>
>CREDITS
>
>*/
#line book.c:87 (book)
>/* (book)
>
>
>NAME
>----
>
>clara - a cooperative OCR
>
>SYNOPSIS
>--------
>
>clara [options]
>
>
>DESCRIPTION
>-----------
>
>Welcome. Clara OCR is a free OCR, written for systems supporting
>the C library and the X Windows System. Clara OCR is intended for
>the cooperative OCR of books. There are some screenshots
>available at CLARA_HOME.
>
>This documentation is extracted automatically from the comments
>of the Clara OCR source code. It is known as "The Clara OCR
>Advanced User's Manual". It's currently unfinished. First-time
>users are invited to read "The Clara OCR Tutorial". Developers
>must read "The Clara OCR Developer's Guide".
>
>
>CONTENTS
>--------
>
>Welcome to Clara OCR
>
>    Early historical notes
>    Design notes
>    Supported Alphabets
>    Clara vs the others
>    The requirements
>    How to download and compile Clara
>    Compilation and startup pitfalls
>
>A first OCR project
>
>    Scanning and thresholding
>    Manual and histogram-based (global)
>    Classification-based (local)
>    Classification-based (global)
>    Avoiding or correcting skew
>    The work directory
>    Building the book font
>    Skeleton tuning
>    Classification tentatives
>    Alignment tuning
>
>Complex procedures
>
>    Using two directories
>    Adding a page
>    Multiple books
>    Adding a book
>    Removing a page
>    Dealing with classification errors
>    Rebuilding session files
>    Importing revision data
>    How to use the web interface
>    Revision acts maintenance
>    Analysing the statistics
>    Upgrading Clara OCR
>
>Reference of the Clara GUI
>
>    The application window
>    Tabs and windows
>    The Application Buttons
>    The Alphabet Map
>
>Reference of the menus
>
>    File menu
>    Edit menu
>    View menu
>    Alphabets menu
>    Options menu
>    PAGE options menu
>    PAGE_FATBITS options menu
>    OCR steps menu
>
>Reference of command-line switches
>
>AVAILABILITY
>
>CREDITS
>
>*/
#line book.c:183 (devel)
>/* (devel)
>
>
>NAME
>----
>
>clara - a cooperative OCR
>
>SYNOPSIS
>--------
>
>clara [options]
>
>
>DESCRIPTION
>-----------
>
>Welcome. Clara OCR is a free OCR, written for systems supporting
>the C library and the X Windows System. Clara OCR is intended for the
>cooperative OCR of books. There are some screenshots available at
>CLARA_HOME.
>
>This documentation is extracted automatically from the comments
>of the Clara OCR source code. It is known as "The Clara OCR
>Developer's Guide". It's currently unfinished. First-time users
>are invited to read "The Clara OCR Tutorial". There is also an
>advanced manual known as "The Clara OCR Advanced User's Manual".
>
>
>CONTENTS
>--------
>
>Introducing the source code
>
>    Language and environment
>    Modularization
>    The memory allocator
>    Security notes
>    Runtime index checking
>    Background operation
>    Global variables
>    Path variables
>    Bitmaps
>    Execution model
>    Return codes
>
>Internal representation of pages
>
>    Closures
>    Symbols
>    The sdesc structure and the mc array
>    The preferred symbols
>    Font size
>    Symbol alignment
>    Words and lines
>    Acts and transliterations
>    Symbol transliterations
>    Transliteration preference
>    Transliteration class computing
>    The zones
>
>Heuristics
>
>    Skeleton pixels
>    Symbol pairing
>    The build step
>    Resetting
>    Synchronization
>    The function list_cl
>
>The GUI
>
>    Main characteristics
>    Geometry of the application window
>    Geometry of windows
>    Scrollbars
>    Displaying bitmaps
>    HTML windows overview
>    Graphic elements
>    XML support
>    Auto-submission of forms
>
>The Clara API
>
>    Redraw flags
>    OCR statuses
>    The function setview
>    The function redraw
>    The function show_hint
>    The function start_ocr
>
>How to change the source code (examples)
>
>    How to add a bitmap comparison method
>    How to write a bitmap comparison function
>    How to add an application button
>
>Bugs and TODO list
>
>AVAILABILITY
>
>CREDITS
>
>
>*/
#line book.c:289 (book)
>/* (book)
>
>Early historical notes
>----------------------
>
>For some years now we have tested and used OCR softwares, mainly
>for old books. Popular OCR softwares (those bundled with
>scanners) are useful tools. However, OCR is not a simple
>task. The results obtained using those programs vary largely
>depending on the the printed document, and, for most texts we're
>interested on, the results are really poor or even unusable. In
>fact, it's not a surprise that many digitalization projects
>prefer not to use OCR, but typists only.
>
>For a programmer, it is somewhat intuitive that OCR could achieve
>good results even from low quality texts, when an add-hoc
>approach is used, focusing one specific book (for
>instance). Within this approach, OCR becomes a matter of finding
>one software adequate for the texts you're trying to OCR, or
>perhaps develop a new one. So a free and easy to customize OCR
>(on the source code level) would be a valuable resource for text
>digitalization projects.
>
>Dealing with graphics is not among our main occupations, but
>after analysing many scanned materials, we began to write some
>simple and specialized recognition tools. More recently (in the
>third quarter of 1999) a simple X interface linked to a naive
>bitmap comparison heuristic was written. From that prototype,
>Clara OCR evolved. Since then, many new ideas from various
>persons helped to make it better.
>
>
>Design notes
>------------
>
>It's not a bad idea to enumerate some principles that have driven
>Clara OCR development. They'll make easier to understand the
>features and limitations of the software (these principles may
>change along time).
>
>1. Clara is an OCR for printed texts, not for handwritten
>texts.
>
>2. Clara was not designed to be used to OCR one or two single
>pages, but to OCR a large number of documents with the same
>graphic characteristics (font, size, etc). So it can take
>advantage of a fine (and perhaps expensive) training. This will
>be tipically the case when OCRing an entire book.
>
>3. We chose not support directly multiple graphic formats, but
>only Jeff Poskanzer's raw PBM and PGM. Non-PBM/PGM files will be
>read through filters.
>
>4. Clara OCR wants to be a tool that makes viable the sum and
>reuse of human revision effort. Because of this, on the OCR model
>implemented by Clara, training and revision are one same
>thing. The revision is a sum of punctual and independent acts and
>alternates with reprocessing steps along a refinement process.
>
>5. The Clara GUI was implemented and behaves like a minimalistic
>HTML viewer. This is just an easy and standard way to implement a
>forms interface.
>
>6. We have tried to make the source code portable across
>platforms that support the C library and the Xlib. Clara has no
>special provision to be ported to environments that do not
>support the Xlib. We avoided to use a higher level graphic
>environment like Motif, GTK or Qt, but we do not discourage
>initiatives to add code to Clara OCR adapt or adapt better to
>these or other graphic environments.
>
>7. We generally try to make the code efficient in terms of RAM
>usage. CPU and disk usage (for session files) are less prioritary.
>
>
>Clara vs the others
>-------------------
>
>Clara differs from other OCR softwares in various aspects:
>
>1. Most known OCRs are non-free and Clara is free. Clara focus
>the X Windows System. Clara offers batch processing, a web
>interface and supports cooperative revision effort.
>
>2. Most OCR softwares focus omnifont technology disregarding
>training. Clara does not implement omnifont techniques and
>concentrate on building specialized fonts (some day in the
>future, however, maybe we'll try classification techniques that
>do not require training).
>
>3. Most OCR softwares make the revision of the recognized text a
>process totally separated from the recognition. Clara
>pragmatically joins the two processes, and makes training and
>revision one same thing. In fact, the OCR model implemented by
>Clara is an interactive effort where the usage of the heuristics
>alternates with revision and visual fine-tuning of the OCR,
>guided by the user experience and feeling.
>
>4. Clara allows to enter the transliteration of each pattern
>using an interface that displays a graphic cursor directly over
>the image of the scanned page, and builds and maintains a mapping
>between graphic symbols and their transliterations on the OCR
>output. This is a potentially useful mechanism for documentation
>systems, and a valuable tool for typists and reviewers. In fact,
>Clara OCR may be seen as a productivity tool for typists, instead
>of a typical OCR.
>
>5. Most OCR softwares are integrated to scanning tools offerring
>to the user an unified interface to execute all steps from
>scanning to recognition. Clara does not offer one such integrated
>interface, so you need a separate software (e.g. SANE) to
>perform scanning.
>
>6. Most OCR softwares expect the input to be a graphic file
>encoded in tiff or other formats. Clara supports only raw
>PBM/PGM.
>
>
>*/
#line book.c:409 (book)
>/* (book)
>
>Scanning and thresholding
>-------------------------
>
>Clara OCR cannot scan paper documents by itself. Scanning must be
>performed by another program. The Clara OCR development effort is
>using SANE (http://www.mostang.com/sane) to produce 600 or 300
>dpi images. The Clara OCR heuristics are tuned to 600 dpi.
>
>Scanners offer three scanning modes: black-and-white (also known
>as "bitmap" or "lineart", however the meaning of these words may
>vary depending on the context), "grayscale" and "color". Clara
>OCR requires black-and-white or grayscale input. Both
>black-and-white and grayscale images may be saved in a variety of
>formats by scanning programs. However, only PBM (for
>black-and-white) and PGM (for grayscale) formats are
>recognized. Generally grayscale 600 or 300 dpi will be the best
>choice, but black-and-white 600 dpi may be good for new, high
>quality printed materials. If your scanning program do not
>support the PBM or PGM formats, try to save the images in TIFF
>format and convert to PBM or PGM using the command tifftopnm. If
>for some reason the TIFF format cannot be used, choose any other
>format that preserves all data (don't use "compressing" formats
>like JPEG), and for which a conversion tool is available, to
>convert it to PBM or PGM.
>
>Remark: Programs that scan or handle (e.g. rotate) images may
>sometimes perform unexpected tasks, as applying dithering or
>reducing algorithms by themselves. An image transformed to become
>nice or small may be useless for OCR purposes.
>
>Remark: The PBM and PGM formats do not carry the original resolution
>(dots-per-inch) at which the image was scanned. As some
>heuristics require that information, Clara OCR expects to be
>informed about it through the command-line switch -y (so take
>note of the resolution used).
>
>Grayscale means that each pixel assumes one gray "level",
>typically from 0 (black) to 255 (white). This is a good choice
>for scanning old or low-quality printed materials, because it's
>possible to use specialized programs to analyse the image and
>choose a "threshold", in such a way that all pixels above that
>threshold will be considered "white", and all others will be
>considered black (when scanning in black-and-white mode, the
>threshold is chosen by the scanning program or by the user). The
>threshold may be global (fixed for the entire page) or local
>(vary along the page).
>
>In most cases grayscale will achieve better results. However, as
>grayscale images are much larger than black-and-white images, 300
>dpi (instead of 600 dpi) may be mandatory when using grayscale
>due to disk consumption requirements.
>
>Remark: Try to limit yourself to the optical resolution oferred by
>the scanner. Most old scanners are 300 dpi, but the scanning
>software obtains higher resolutions through interpolation. Newer
>scanners may be optical 600 dpi or 1200 dpi or more.
>
>Remark: the page 143 of Manuel Bernardes Branco Dictionary that
>we're using along these tests was scanned using the SANE
>scanimage command:
>
>    scanimage -d microtek2:/dev/sga --mode gray -x 150 -y 210
>              --resolution 300 > 143.pgm
>
>Thresholding is not the only method for converting grayscale
>images to black-and-white (such conversion is also called
>"binarization"), but it's the current method used by Clara OCR.
>In practice, a too low threshold will brake many symbols on their
>thin parts, and a too high threshold will link symbols together
>(in the figure, an "a-i" link and a broken "u").
>
>               XX                  
>               XX                  
>                                
>     XXXXX    XXX      XXX   XXX   
>    X     XX   XX       XX    XX   
>          XX   XX       XX    XX   
>     XXXXXXX   XX       XX    XX   
>    X     XX   XX       XX    XX   
>    X     XX   XX       XX    XX   
>     XXXXX XXXXXXX       XX  XXXX  
>
>It's a hard task to detect broken and linked symbols. The Clara OCR
>heuristics that handle these cases are incipient, so thresholding must
>must be carefully performed, in order to not compromise the OCR
>results. If the printing intensity, the noise level or the paper
>quality vary from page to page, thresholding must be performed on a
>per-page basis.
>
>Remark: Now you can try avoid links in segmentation step. 
>Just set "Try avoid links" parameter in Tune tab. (Normal values <=1)
>
>The four thresholding methods currently avaliable are: manual
>(global), histogram-based (global), classification-based (local),
>classification-based (global).
>
>Manual and histogram-based (global)
>-----------------------------------
>
>Histogram-based thresholding is the default method. It computes
>automatically a thresholding value based on the distribution of
>grayshades. To use it, just enter the TUNE tab and select (it's
>selected by default) the "use histogram-based global
>thresholder". To make a try, load a PGM image and press OCR or
>ask the Segmentation OCR step.
>
>Remark: You can correct the automatic-detected threshold with 
>"Threshold factor" in Tune tab.
>
>A global thresholding value can be manually specified. This
>corresponds to the "use manual global thresholder" entry. The
>choice of the thresholding value is performed through a visul
>interface called "instant thresholding". To use it, load one PGM
>image and select the "Instant thresholding" entry (Edit
>menu). Then use '<', '>', '+' and '-' to change the thresholding
>value. When ok, press ESC. Note that the selected value will be
>applied only when the segmentation step runs.
>
>
>Classification-based (local)
>----------------------------
>
>Global thresholding does not address those cases where the
>printing intensity (or paper properties) vary along one same
>page. Local thresholding methods are required on such
>cases. Clara OCR implements a classification-based local
>(per-symbol) thresholder. Saying that it's classification-based
>means that the OCR engine is used to choose the threshold. In
>other words, the threshold chosen is that for which the
>classifier successfully recognized the symbol (in fact, this is a
>brute-force approach).
>
>The local binarizer can be manually applied at any symbol. To do
>so, load one PGM page and click any symbol directly on the PAGE
>tab. Two thresholding values will be chosen. The pixels found to
>be "black" for each one are painted "black" (smaller value) and
>"gray" (larger value). At this moment, it's possible to add the
>thresholded symbol as a pattern (just press the key corresponding
>to its transliteration). Remember that this thresholder relies on
>the classifier, so if the OCR is not trained, you'll get no
>benefit.
>
>Two versions of the local binarizer were developed, a "weak" one
>and a "strong" one. The "weak" one just tries to change the
>threshold on those symbols not successfully classified using the
>default threshold. The "strong" one (unfinished) also tries to
>criticize locally the segmentation results. By default, the weak
>version is used. To try the strong one, check the corresponding
>checkbox at the TUNE tab.
>
>Remark: As an alternative, use the "Balance" feature + global thresholding.
>
>
>Classification-based (global)
>-----------------------------
>
>Clara OCR includes a simple threshold selection script to compute
>global best thresholds based on classification results. Let's try
>it on our 2-page book. Just create a directory, cd to it and run
>the selthresh script informing the resolution and the names of
>the images:
>
>    $ cd /home/clara/books/BC
>    $ mkdir pbm
>    $ cd pbm
>    $ selthresh -y 300 -l 0.45 0.55 ../pgm/\*pgm
>    selthresh: scaling 2 times
>    Best thresholds:
>    143-l.pgm 0.49
>    143-r.pgm 0.51
>
>In this case, selthresh will require around 4 minutes to
>complete on a 500MHz CPU. For larger collections of pages,
>selthresh may take much longer to complete (hours or days). If
>needed, the execution can be safely interrupted using Control-C
>(it's ok to shutdown the machine while selthresh is
>running). The execution can be safely restarted from the point
>where it was interrupted typing again the same command:
>
>    $ cd /home/clara/books/MBB/pbm
>    $ selthresh -y 300 -l 0.40 0.55 ../pgm/\*pgm
>
>The option -l is used to inform an interval of thresholds to
>try. By now, selthresh is unable to choose by itself a "good"
>interval. The user must manually check the results for some
>thresholds in order to make a choice. For instance, to examine
>the results for threshold 0.4 on page 143-l.pgm, try:
>
>    $ pgmtopbm -threshold -value 0.4 ../pgm/143-l.pgm >143-l.pbm
>    $ display 143-l.pbm
>
>Change the threshold, repeat and, once found a threshold value
>that produces a "nice" visual result, specify to -l the interval
>centered at that threshold, and total width 0.1 or 0.2. The same
>interval may be used for all pages because selthresh will warn
>about a bad interval choice. Example:
>
>    $ selthresh -y 300 -l 0.30 0.35 ../pgm/143-l.pgm
>    selthresh: scaling 2 times
>    Best thresholds:
>    143-l.pgm 0.32 (bad interval, try -l 0.30 0.4)
>
>If a "bad interval" warning appears on the final output for some
>pages, it's ok to restart selthresh informing a new, wider
>interval, as suggested by selthresh. Only the suspicious pages
>will be re-examined. In fact, selecting a narrow initial interval
>(and making it larger as required) may be a good strategy to
>reduce the total running time.
>
>Once the best thresholds are known, use pgmtopbm to produce the
>black-and-white images. It's also a good idea to approach the
>resolution to 600 dpi using pnmenlarge. Yet pnmenlarge does not
>add information to the image, the classification heuristics will
>behave better. In our case, the command should be
>
>    $ cd /home/clara/books/BC/pbm
>    $ pnmenlarge 2 ../pgm/143-l.pgm | \
>          pgmtopbm -threshold -value 0.49 >143-l.pbm
>    $ pnmenlarge 2 ../pgm/143-r.pgm | \
>          pgmtopbm -threshold -value 0.51 >143-r.pbm
>
>Remark: it's not a bad idea to visualize the PBM files, or at least
>some of them. Yet selthresh produced good results for us, your
>mileage may vary.
>
>In order to capture the output of selthresh (to extract the
>per-page best thresholds), it's ok to re-generate it as many
>times as needed (just repeat the same selthresh command,
>because once all computations become performed, the script will
>just read the results from selthresh.out and output the results).
>
>A final warning: selthresh may be fooled by too dark images. So
>if the right limit is much larger than it should be, selthresh
>may produce bad results. So be careful concerning the right limit
>of the interval. As a practical advice, keep in mind that the
>best threshold for most images is less then 0.6. In the near
>future we'll use statistical measurements to choose the interval
>to analyse, in order to prevent such problems and to make
>unnecessary a manual choice.
>
>remark: the tarball also includes an alternative selthresh, named
>slethresh_fidian.pl. It contains instructions on how to use it.
>
>
>Avoiding or correcting skew
>---------------------------
>
>Sometimes the printing is skewed relatively to the paper
>margins. Skew is a problem to the OCR heuristics. As the Clara
>OCR engine just detects components by pixel contiguity and builds
>classes of symbols, in practice the effect of skew will be a
>larger number of patterns, and therefore a larger revision cost.
>
>In some cases, a careful manual scanning can solve the
>problem. When acceptable, a set-square solves the problem: just
>align one text line at one set-square rule and the edge of the
>scanner glass at the other rule (we're supposing that the
>bookbinding was disassembled).
>
>The bundled preprocessor now includes a method to compute and
>correct skew, but it's not on by default. To activate it, enter
>the TUNE tab and select the "Use deskewer" checkbox. Now
>deskewing will be applied when the OCR button is pressed (or when
>the "Preprocessing" OCR step is requested). Note that
>preprocessing is called only once per page, so if the page was
>already preprocessed, it won't be deskewed.
>
>
>Skeleton tuning
>---------------
>
>Currently, symbol classification can be performed by three
>different classifiers: skeleton fitting, border mapping or pixel
>distance. The choice is done on the TUNE tab. Border mapping is
>currently experimental. Pixel distance has been used as an
>auxiliar classifier. Skeleton fitting is a more mature code and
>is highly customizable. It's the default classification method by
>now.
>
>When using skeleton fitting, two symbols are considered similar
>when each one contains the skeleton of the other. So the
>classification result depends strongly on how skeletons are
>computed. As an example, the figure presents one symbol
>("e"). The symbol black pixels are the dots ('.'). The skeleton
>black pixels are stars ('*').
>
>        .......
>       ..******..
>      .*.    ..*..
>     ..*.    ...*.
>     .*..    ...*..
>    ..*.........*..
>    ..***********..
>    ..*.      ....
>    ..*.
>    ..*..
>    ..*...     ...
>     ..*..........
>      ..********..
>       .........
>
>
>Clara OCR offers seven different methods for computing
>skeletons. Each method has tunable parameters. The choice of the
>method and the parameters can be done through a visual inteface
>on the TUNE (SKEL) tab. To try it, first save the session (menu
>"File"), then enter that tab. At least one pattern must
>exist. Vary the parameters and observe the results. Press the
>left and right arrows to navigate through the patterns, and use
>the "zoom" button to choose a comfortable image size. The last
>selection will be used for all skeleton computations. To discard
>it, exit Clara OCR without saving the session.
>
>Instead of trying the TUNE (SKEL) tab, it's possible to specify
>skeleton computation parameters through the -k command-line
>switch. Note however that if a selection was performed through
>the TUNE (SKEL) tab, that selection will override the parameters
>informed to -k, so be careful.
>
>Clara OCR has an auto-tune feature to choose the "best" skeleton
>computation parameters. To use it, check the "Auto-tune skeleton
>parameters" entry on the TUNE tab. This feature is currently left
>off by default because manual tuning can achieve better
>results. Examples:
>
>1. Quality printing without thin details
>
>    use -k 2,1.4,1.57,10,3.8,10,4,4
>     or -k 0,1.4,1.57,10,3.8,10,4,4
>
>2. Quality printing with thin details
>
>    use -k 2,1.4,1.57,10,3.8,10,1,1
>     or -k 4,,,,,,3,
>
>3. Poor printing without thin details
>
>    use -k 2,1.4,1.57,10,3.8,10,1,1
>
>4. Poor printing with thin details
>
>    use -k 2,1.4,1.57,10,3.8,10,1,1
>
>Yet the pattern computation parameters may change along the way,
>it's wise to choose adequate skeleton computation parameters
>before OCRing, and keep them fixed along the project. Every time
>Clara OCR is started, inform the same parameters chosen. In our
>case, we can use the default parameters. To do so, just enter
>Clara OCR as before:
>
>    $ cd /home/clara/books/BC/pbm
>    $ clara &
>
>
>Classification tentatives
>-------------------------
>
>To classify the book symbols (i.e. to discover the
>transliteration of unknown symbols using the patterns), enter
>Clara OCR, select "Work on all pages" ("Options" menu) and press
>the OCR button using the mouse button 1, or press the mouse
>button 3 and select "Classification". The classification may be
>performed many times. Each time, different parameters may be
>tried to refine the results already achieved.
>
>When the classification finishes, observe the pages 5.pbm and
>6.pbm. Much probably, some symbols will be greyed. In other
>words, the classifier was unable to classify all symbols. The
>statistics presented on the PAGE (LIST) tab may be useful now. To
>reduce the number of unknown symbols there are three choices: add
>more patterns, change the skeleton computation parameters, or try
>another classifier.
>
>To add more patterns, just train some greyed symbols and
>reclassify all pages again. The reclassification will be faster
>than the first classification because most symbols, already
>classified, won't be touched.
>
>To change the skeleton computation parameters, exit Clara OCR,
>restart it informing the new parameters through -k, select
>"Re-scan all patterns" ("Edit" menu), select "Work on all pages"
>("Options" menu) and reclassify. May be easier to choose and set
>the new parameters using the TUNE (SKEL) tab, as explained
>earlier. However, remember that the parameters chosen through the
>TUNE (SKEL) tab override the parameters informed through -k.
>
>To try another classifier, first select the "Re-scan all
>patterns" entry on the "Edit" menu. Then enter the TUNE tab and
>select the classifier to use from the available choices
>(skeleton-base, border mapping and pixel distance). The pixel
>distance may be a good choice. Then reclassify all pages.
>
>The "Re-scan all patterns" is required because for each symbol
>Clara OCR remembers the patterns already tried to classify it,
>and do not try those patterns again. However, when the skeleton
>computation parameters change, or when the classifier changes,
>those same patterns must be tried again. Maybe in the future
>Clara OCR will decide by itself about re-scanning all patterns.
>
>
>Symbol properties
>-----------------
>
>The bottom five buttons (alphabet, pattern type, "bold", "italic"
>and "bad") carry the properties of the current symbol. If the
>"PAGE" window is on the plate, the current symbol is the one
>identified by the graphic cursor. If the window "PATTERN" is on
>the plate, the current symbol is the pattern being exhibited. In
>all other cases, the current symbol is undefined.
>
>Let's comment in detail the symbol properties carried by those
>five buttons:
>
>a. The possible values for the alphabet are: latin, greek,
>cyrillic, hebrew, arabic, kana, number, ideogram or "other". In
>order to limit the available alphabets, the button circulates
>only the values selected on the "Alphabet" menu.
>
>b. The "pattern types" are the fonts and font sizes used by the
>book. Example: 12pt roman and 12pt arial for the text, and 8pt
>roman for the footnotes. In this case we have three "types"
>identified as "1", "2" and "3".
>
>c. Each one of the bold, italic and "bad" flags may be on or
>off. The "bad" flag identifies a symbol not to be used as
>pattern.
>
>The user can inform Clara OCR about any of these properties for
>the current symbol, just selecting the desired value on the
>corresponding button (click it one or more times). The pattern
>type, however, is read-only by default. To allow changing its
>value, use the "pattern types are read-only" entry on the
>"Options" menu.
>
>In most cases, Clara OCR will compute automatically the
>properties of each symbol, so it's not required to set them
>manually. But just like the transliterations, Clara OCR will need
>some initial information, so the user must identify some symbols
>as being bold or italicized.
>
>
>Merge tuning
>------------
>
>    merge internal fragments
>    merge pieces on one same box
>    merge close fragments
>    recognition merging
>    learned merging
>
>
>Complex procedures
>------------------
>
>To OCR an entire book is a long process. Perhaps along it a
>problem is detected. Bad choice of skeleton computation
>parameters, or a bad page contaminating the bookfont, some files
>loss due to a crash, etc. How to solve them?
>
>Clara OCR does not offer currently a complete set of tools to
>solve all these problems. In some cases, a simple solution is
>available. In others, a solution is expected to become available
>in future versions. This session will depict some practical
>cases, and explain what can be done and what cannot be done for
>each one.
>
>Fixing transliterations
>-----------------------
>
>  Fixing pattern transliterations
>  Fixing symbol transliterations
>
>Removing patterns and synchronizing pages
>-----------------------------------------
>
>  Removing references to that pattern
>      on the loaded page
>      on other pages
>      on the patter types
>
>Removing a page
>---------------
>
>From the stats presented by the PAGE (LIST) tab it's possible to
>detect problems on specific pages. A low factorization may be a
>simptom of a bad choice of brightness for that page. In such a
>case, it's probably a good idea to remove completely that page.
>
>To remove a page is a delicate operation. Clara OCR currently
>does not offer a "remove page" feature. Basically, it should
>remove all patterns from that page, remove the revision data
>acquired from that page, and remove the page image and its
>session file.
>
>
>Dealing with classification errors
>----------------------------------
>
>What to do when the OCR classifies incorrectly a large quantity of
>symbols? (to be written)
>
>
>Importing revision data
>-----------------------
>
>When OCRing a large book, a good approach is to divide its pages
>into a number of smaller sections and OCR each one. So for a book
>with, say, 1000 pages, we could OCR pages 1-200, then 201-400,
>etc.
>
>After finishing the first section, of course we desire reuse on
>the second section the training and revision effort already
>spent. This is not the same as adding the pages 201-400 to the
>first section, because we do not want handle the pages 1-200
>anymore.
>
>Basically we need to import the patterns of the first section
>when starting to process the second. Well, Clara OCR is currently
>unable to make this operation.
>
>
>How to use the web interface
>----------------------------
>
>The Clara OCR web interface allows remote training of symbols. To use
>it, a web server able to run perl CGIs (e.g. Apache) is
>required. Let's present the steps to activate the web interface for a
>simple case, with only one book (named "book1"). Basically, one needs
>to create a subtree anywhere on the server disk (say,
>"/home/clara/www/"), owned by the user that will manage the project
>(say, "clara"), with subdirectories, "bin", "book1" and
>"book1/doubts":
>
>    $ id
>    uid=511(clara) gid=511(clara) groups=511(clara)
>    $ cd /home/clara/
>    $ mkdir www
>    $ cd www
>    $ mkdir bin book1
>    $ mkdir book1/doubts
>
>Then copy to the directory "bin" the files clara.pl and sclara.c from
>the Clara OCR distribution (say, /usr/local/src/clara), edit clara.c
>to change the hardcoded definition of the root directory to
>"/home/clara/www", compile it and make it setuid:
>
>    $ cd bin
>    $ cp /usr/local/src/clara/clara.pl .
>    $ cp /usr/local/src/clara/sclara.c .
>    $ emacs sclara.c
>    $ grep '^char *root' sclara.c
>    char *root = "/home/clara/www";
>    $ cc -o sclara -static sclara.c
>    $ rm sclara.c
>    $ chmod a+s sclara
>
>Edit the script clara.pl. Example for the clara.pl configuration
>section (the script clara.pl contains default definitions for some of
>these variables, please comment out those definitions):
>
>    $CROOT = "/home/clara/www";
>    $U = "/cgi-bin/clara";
>    $book[0] = 'Author, <I>Test 1</I>, City, year';
>    $subdir[0] = "book1";
>    $LANG = 'en';
>    $opt = '-W -R 10 -b -k 2,1.4,1.57,10,3.8,10,4,1';
>
>Now copy the PBM files to the directory "book1", create low-quality
>jpeg previews, gzip the PBM files, and select some patterns:
>
>    $ cd /home/clara/www/book1
>    $ cp /usr/local/src/clara/imre.pbm .
>    $ pbmreduce 8 imre.pbm | convert -quality 25 - imre.jpg
>    $ gzip -9 imre.pbm
>    $ clara -k 2,1.4,1.57,10,3.8,10,4,1
>
>(load one PBM file, train some symbols, save the session and quit the
>program).
>
>Now we need to process the PBM files in order to create some
>"doubts". The script clara.pl also requires a symlink to the clara
>binary (change the path /usr/local/bin/clara as required):
>
>    $ cd /home/clara/www/bin
>    $ ln -s /usr/local/bin/clara clara
>    $ ./clara.pl -s book1
>    $ rm ../book1/\*html
>    $ ./clara.pl -p
>
>Now your server must be instructed to exec /home/clara/www/bin/clara.pl
>when a visitor requests "/cgi-bin/clara" (if you prefer another URL,
>change the clara.pl customization too). An easy way to accomplish that
>is creating a symlink on the default directory for CGIs. The default
>directory of CGIs is platform-dependent (e.g. /home/httpd/cgi-bin,
>/usr/local/httpd/cgi-bin, /var/lib/apache/cgi-bin, etc). Example:
>
>    # cd /home/httpd/cgi-bin
>    # ln -sf /home/clara/www/bin/clara.pl clara
>
>Try to access the URL "/cgi-bin/clara" on your web server. The correct
>behaviour is successfully loading a page entitled "Prototype of the
>Cooperative Revision". If you have problems, be aware about some
>common problems:
>
>1. Apache expects to be explicitly allowed to follow symlinks. The
>file access.conf should contain, in our case, a section similar to the
>following:
>
>    <Directory /home/httpd/cgi-bin>
>    AllowOverride None
>    Options ExecCGI FollowSymLinks
>    </Directory>
>
>2. The directory /home/clara must be world readable:
>
>    # ls -ld /home/clara
>    drwxr-xr-x  4 clara clara  1024 Sep 17 09:56 /home/clara
>
>If you succeeded, congratulations! Note that from time to time it'll
>be necessary to reprocess the pages, adding to the session files the
>data collected from the web, just like done before:
>
>    $ cd /home/clara/www/bin
>    $ ./clara.pl -p
>    $ ./clara.pl -s book1
>
>
>Revision acts maintenance
>-------------------------
>
>Types of revision acts (to be written).
>
>Discarding deduced data (to be written).
>
>
>
>*/
#line book.c:1049 (devel)
>/* (devel)
>
>Bugs and TODO list
>------------------
>
>(Some) Major tasks
>
>1. Vertical segmentation (partially done).
>
>2. Heuristics to merge fragments.
>
>3. Spelling-generated transliterations
>
>4. Geometric detection of lines and words
>
>5. Finish the documentation
>
>6. Simplify the revision acts subsystem
>
>
>Minor tasks
>
>1. Change sprintf to snprintf.
>
>2. Fix assymetric behaviour of the function "joined".
>
>3. Optimize bitmap copies to copy words, not bits, where possible
>(partially done).
>
>4. Support Multiple OCR zones (partially done).
>
>5. Make sure that the access to the data structures is blocked
>during OCR (all functions that change the data structures must
>check the value of the flag "ocring").
>
>6. Use 64-bit integers for bitmap comparisons and support
>big-endian CPUs (partially done).
>
>7. Clear memory buffers before freeing.
>
>8. Allow the transliterations to refer multiple acts (partially
>done).
>
>9. Rewrite composition of patterns for classification of linked
>symbols.
>
>10. The flea stops but do not disappear when the window lost and
>regain focus.
>
>11. Substitute various magic numbers by per-density and
>per-minimum-fontsize values.
>
>12. Synchronization destroys the result of partial matching
>because partial matching assigns to the symbol only one
>pattern as its best match.
>
>*/
#line book.c:1107 (book)
>/* (book)
>
>Welcome to Clara OCR
>--------------------
>
>Clara is an optical character recognition (OCR) software, a
>program that tries to identify the graphic images of the
>characters from a scanned document, converting their digital
>images to ASC, ISO or other codes.
>
>The name Clara stands for "Cooperative Lightweight chAracter
>Recognizer".
>
>Clara offers two revision interfaces: a standalone GUI and and a
>web interface, able to be used by various different reviewers
>simultaneously. Because of this feature Clara is a "cooperative"
>OCR (it's also "cooperative" in the sense of its free/open status
>and development model).
>
>
>
>*/
#line book.c:1130 (book)
>/* (book)
>
>
>The requirements
>----------------
>
>Clara OCR will run on a PC (386, 486 or Pentium) with GNU/Linux
>and Xwindows. Clara OCR will hopefully compile and run on a PC
>with any unix-like operating system and Xwindows. Currently Clara
>OCR won't run on big-endian CPUs (e.g. Sparc) nor on systems
>lacking X windows support (e.g. MS-Windows). Higher-level
>libraries like Motif, GTK or Qt are not required.
>
>A relatively fast CPU is recommended (300MHz or more). Memory
>usage depends on the documents, and may range from some few
>megabytes to various tenths os megabytes The normal operation
>will create session files on your hard disk, so some megabytes of
>free disk space are required (a large project may require plents
>of gigabytes). Clara OCR can read and write gzipped files (see
>the -z command-line switch).
>
>If you need to build the executable and/or the documentation,
>then an ANSI C compiler (with some GNU extensions) and a (version
>5) perl interpreter are required.
>
>
>How to download and compile Clara
>---------------------------------
>
>For those who need to download and compile the source code
>(hopefully this will be unnecessary for most users as soon as
>Clara binary distributions become available), it may be
>downloaded from CLARA_HOME. It's a
>compressed tar archive with a name like clara-x.y.tar.gz (x.y is
>the version number).
>
>The compilation will generally require no more than issue the
>following commands on the shell prompt:
>
>    $ gunzip clara-x.y.tar.gz
>    $ tar xvf clara-x.y.tar
>    $ cd clara-x.y
>    $ make
>    $ make doc
>
>Now you can copy the executable (the file "clara") to some
>directory of binaries (like /usr/local/bin), and the man page
>(file "clara.1") to some directory of man pages (like
>/usr/local/man/man1). By now there is no "make install" to
>perform these copies automatically.
>
>If some of these steps fail, please try to obtain assistance from
>your local experts. They will solve most simple problems
>concerning wrong paths or compiler options. You can also read the
>subsection "Compilation and startup pitfalls".
>
>
>Compilation and startup pitfalls
>--------------------------------
>
>This subsection is intended to help people that are experiencing
>fatal errors when building the executable or when starting
>it. After each error message we'll point out some hints.
>
>Bear in mind that most hints given below are very elementary
>concerning Unix-like systems. If you have problems, try to read
>all hints because details explained once are not repeated. If you
>cannot understand them, please try to ask your local experts, or
>try to read an introductory book on Unix things. Please don't
>email questions like these to the Clara developers, except when
>the hint suggests it.
>
>1. Path-related pitfalls
>
>    $ make
>    bash: make: command not found
>
>The shell could not find the "make" utility. Maybe there is no
>such utility installed on your system, or maybe the path to it is
>unknown to the shell. You can try to find the "make" utility with
>a command like
>
>    $ find /usr -name make -print
>
>The following command will display the current path:
>
>    $ echo $PATH
>
>Remember that on Unix-like systems the environment is
>per-process. So if you change the PATH variable on the shell
>prompt within an xterm, this won't affect the other running
>shells (on the other xterms). Remember that the Unix shells
>expect to be explicitly informed about which variables must be
>exported to subprocesses (use "export" in Bourne-like shells and
>"setenv" on C-like shells).
>
>    $ make
>    gcc -I/usr/X11R6/include -g   -c gui.c -o gui.o
>    make: gcc: Command not found
>    make: *** [gui.o] Error 127
>
>The make utility could not find the gcc compiler. Check if gcc is
>installed. If not, check if some other C compiler is installed
>(for instance, "cc"), and edit the makefile to chage the value of
>the CC variable.
>
>If you don't know what I'm speaking about, take a look on the
>directory where the Clara source codes are, and you'll see there
>a file named "makefile". This file contains the names of the
>tools to be used and rules to build the Clara executable. It
>contains also important paths, like those where the system
>headers (files .h) and libraries can be found. If the names or
>the paths don't reflect those on your system, you need to edit
>the makefile accordingly.
>
>    $ make
>    gcc -I/usr/X11R6/include -g   -c gui.c -o gui.o
>    In file included from gui.c:16:
>    gui.h:12: X11/Xlib.h: No such file or directory
>    make: *** [gui.o] Error 1
>
>The compiler could not find the header Xlib.h. Maybe your system
>does not include such header, or maybe it is on another directory
>not explicited on the makefile through the INCLUDE variable.
>
>    $ make
>    gcc -o clara clara.o skel.o gui.o mc.o ...
>    /usr/bin/ld: cannot open -lX11: No such file or directory
>    make: *** [clara] Error 1
>
>The linker could not find the X11 library. Maybe your system does
>not include such library, or maybe it is on another directory not
>explicited on the makefile through the LIBPATH variable.
>
>2. Compilation pitfalls
>
>    $ make
>    gcc -I/usr/X11R6/include -g   -c clara.c -o clara.o
>    clara.c:70: parse error before `int'
>    make: *** [clara.o] Error 1
>
>A syntax error on the line 70 of the file clara.c. Double check
>if the sources were not changed. Try to obtain the sources
>again. If you're a programmer, try to fix the problem. In any
>case, report it to claraocr@claraocr.org.
>
>    $ make
>    clara.c: In function `process_cl':
>    clara.c:2293: `ZPS' undeclared (first use in this function)
>    clara.c:2293: (Each undeclared identifier is reported only once
>    clara.c:2293: for each function it appears in.)
>    make: *** [clara.o] Error 1
>
>A reference to an undeclared variable. Double check if the
>sources were not changed. Try to obtain the sources again. If
>you're a programmer, try to fix the problem. In any case, report
>it to claraocr@claraocr.org.
>
>
>3. Runtime pitfalls
>
>    $ clara &
>    [1] 1924
>    bash: clara: command not found
>
>The Clara executable does not exist or is not on the path. Most
>Unix systems don't include the current directory ("./") on the
>path, so if you're trying to start Clara from the directory where
>it was compiled, specify the current directory ("./clara").
>
>    $ ./clara &
>    [1] 1922
>    _X11TransSocketUNIXConnect: Can't connect: errno = 111
>    cannot connect to X server
>
>Clara could not connect the X server. The X Windows System is a
>client-server system. The applications (xterm, xclock, etc)
>connect to a display server (the X server). If the server is not
>running, clients cannot connect to it. In some cases, it's
>required to inform explicitly the client about the server it must
>connect, using the environment variable DISPLAY.
>
>    $ ./clara
>    Segmentation fault (core dumped)
>
>If you can reproduce the problem, report it
>to claraocr@claraocr.org. If you're a programmer and Clara was
>compiled with the -g option, try a debugger to locate the point
>of the source code where the segmentation fault happened. Using
>gdb, it's quite easy:
>
>    $ gdb clara
>    (gdb) run
>
>Now try to reproduce the steps that led to the segmentation
>fault.
>
>
>*/
#line book.c:1330 (tutorial)
>/* (tutorial)
>
>Making OCR
>----------
>
>This section is a tutorial on the basic OCR features offerred by
>Clara OCR. Clara OCR is not simple to use. A basic knowledge
>about how it works is required for using it. Most complex
>features are not covered by this tutorial. If you need to compile
>Clara from the source code, read the INSTALL file and check (if
>necessary) the compilation hints on the Clara OCR Advanced User's
>Manual.
>
>
>Starting Clara
>--------------
>
>So let's try it. Of course we need a scanned page to do so. Clara
>OCR requires graphic format PBM or PGM (TIFF and others
>must be converted, the netpbm package contains various conversion
>tools). The Clara distribution package contains one small PBM
>file that you can use for a first test. The name of this file is
>imre.pbm. If you cannot locate it, download it or other files
>from CLARA_HOME. Alternatively, you can produce your own 600-dpi
>PBM or PGM files scanning any printed document (hints for
>scanning pages and converting them to PBM are given on the
>section "Scanning books" of the Clara OCR Advanced User's
>Manual).
>
>Once you have a PBM or PGM file to try, cd to the directory where
>the file resides and fire up Clara. Example:
>
>    $ cd /tmp/clara
>    $ clara &
>
>In order to make OCR tests, Clara will need to write files on
>that directory, so write permission is required, just like some
>free space.
>
>Remark: As to version CLARA_VERSION, Clara OCR heuristics are tuned
>to handle 600 dpi bitmaps. When using a different resolution,
>inform it using the -y switch:
>
>    $ clara -y 300 &
>
>Then a window with menus and buttons will appear on your X
>display:
>
>
>    +-----------------------------------------------+
>    | File Edit OCR ...                             |
>    +-----------------------------------------------+
>    | +--------+     +----+ +--------+ +-------+    |
>    | |  zoom  |     |page| |patterns| | tune  |    |
>    | +--------+   +-+    +-+        +-+       +-+  |
>    | +--------+   | +-------------------------+ |  |
>    | |  zone  |   | |                         | |  |
>    | +--------+   | |                         | |  |
>    | +--------+   | |                         | |  |
>    | |  OCR   |   | |        WELCOME TO       | |  |
>    | +--------+   | |                         | |  |
>    | +--------+   | |    C L A R A    O C R   | |  |
>    | |  stop  |   | |                         | |  |
>    | +--------+   | |                         | |  |
>    |      .       | |                         | |  |
>    |      .       | |                         | |  |
>    |              | |                         | |  |
>    |              | |                         | |  |
>    |              | +-------------------------+ |  |
>    |              +-----------------------------+  |
>    |                                               |
>    | (status line)                                 |
>    +-----------------------------------------------+
>
>
>Welcome aboard! The rectangle with the welcome message is called
>"the plate". As you already guessed, the small rectangles with
>the labels "zoom", "OCR", "stop", etc, are "the buttons". The
>"tabs" are those flaps labelled "page", "patterns"
>and "tune". On the menu bar you'll find the File menu, the Edit
>menu, and so on. Popup the "Options" menu, and change the current
>font size for better visualization, if required.
>
>Press "L" to read the GPL, or select the "page" tab, and
>subsequently, select on the plate the imre.pbm page (or any other
>PBM or PGM file, if any). The OCR will load that file showing the
>progress of this operation on the status line on the bottom of
>the window.
>
>note: the "page" tab is the flap labelled "page". This is
>unrelated to the "tab" key.
>
>When the load operation completes, Clara will display the
>page. Press the OCR button and wait a bit. The letters will
>become grayed and the plate will split into three windows. Move
>the pointer along the plate and you'll see the tab label follow
>the current window: "page", "page (output)" or "page
>(symbol)". Move the pointer along the entire application window,
>and, for most components, you'll see a short context help message
>on the status line when the pointer reaches it (the buttons, for
>instance). Dialogs (user confirmations) also use the status line
>(like Emacs), instead of dialog boxes.
>
>You can resize both the Clara application window or each of the
>three windows currently on the plate ("page", "page (output)" and
>"page (symbol)"). To resize the windows, select any point between
>two of them and drag the mouse. The scrollbars can become hidden
>(use the "hide scrollbars" on the View menu).
>
>When the tab label is "page", press the "zoom" button using the
>mouse button 1 and the scanned image will zoom out. If you use
>the mouse button 3, the image will zomm in (the behaviour of the
>"zoom" button depends on the current window).
>
>Now try selecting the "page" tab many times, and you will
>circulate the various display modes shared by this tab. These
>modes are and will be referred as "PAGE", "PAGE (fatbits)" and
>"PAGE (list)". Each display mode may have one or more windows
>We've chosen this uncommon approach because an excess of tabs
>transforms them in a useless decoration. The other tabs also
>offer various modes, some will be presented later by this
>tutorial.
>
>
>Some few command-line switches
>------------------------------
>
>Besides the -y option used in the last subsection, Clara accepts
>many others, documented on the Clara OCR Advanced User's
>Manual. By now, from the various different ways to start Clara,
>we'll limit ourselves to some few examples:
>
>  clara
>  clara -h
>
>In the first case, Clara is just started. On the second, it will
>display a short help and exit.
>
>  clara -f path
>  clara -f path -w workdir
>
>The option -f informs the relative or absolute path of a scanned
>page or a directory with scanned pages (PBM or PGM files). The
>option -w informs the relative or absolute path of a work
>directory (where Clara will create the output and data files).
>
>  clara -i -f path -w workdir
>  clara -b -f path -w workdir
>
>The option -i activates dead keys emulation for composition of
>accents and characters. The -b switch is for batch
>processing. Clara will automatically perform one OCR run on the
>file informed through -f (or on all files found, if it is the
>path of a directory) and exit without displaying its window.
>
>  clara -Z 1 -F 7x13
>
>Clara will start with the smallest possible window size.
>
>A full reference of command-line switches is given on the section
>"Reference of command-line switches" of the Clara OCR Advanced
>User's Manual.
>
>
>Training symbols
>----------------
>
>Yes, Clara OCR must be trained. Training is a tedious procedure,
>but it's a must for those who need a customizable OCR, apt to
>adapt to a perhaps uncommon printing style.
>
>Before training, a process called segmentation must be
>performed. Press the right button of the mouse over the OCR
>button, select "Segmentation" on the menu that will pop out and
>wait the operation complete.
>
>Now, on the "page" tab, observe the image of the document
>presented on the top window. You'll see the symbols greyed,
>because the OCR currently does not know their
>transliterations. Try to select one symbol using the mouse (click
>the mouse button 1 over it). A black elliptic cursor will appear
>around that symbol. This cursor is called the "graphic
>cursor". You can move the graphic cursor around the document
>using the arrow keys.
>
>Now observe the bottom window on the "page" tab. That window
>presents some detailed information on the current symbol (that
>one identified by the graphic cursor). When the "show web clip"
>option on the "View" menu is selected, a clip of the document
>around the current symbol, is displayed too. In some cases, this
>clip is useful for better visualization. The name "web clip" is
>because this same image is exported to the Clara OCR web
>interface when cooperative training and revision through the
>Internet is being performed.
>
>To inform the OCR about the transliteration of one symbol, just
>type the corresponding key. For instance, if the current symbol
>is a letter "a", just type the "a" key. Observe that the trained
>symbol becomes black. Each symbol trained will be learned by the
>OCR, its bitmap will be called a "pattern", and it will be used
>as such when trying to deduce the transliteration of unknown
>symbols.
>
>Remark: in our test, the user chose the symbol to be trained. However,
>Clara OCR can choose by itself the symbols to be trained. This feature
>is called "build the bookfont automatically" (found on the "tune"
>tab). To use it, select the corresponding checkbos and classify the
>symbols as explained later.
>
>Finally, when the transliteration cannot be informed through one
>single keystroke or composition (for instance when you wish to
>inform a TeX macro as being the transliteration of the current
>symbol), write down the transliteration using the text input
>field on the bottom window (select it using the mouse before).
>
>
>Symbol properties
>-----------------
>
>Obs: most features described in this paragraph are still
>experimental.
>
>The bottommost three buttons (in this order: alphabet, pattern
>type, and "bad") show properties of the current symbol.
>
>If a symbol is defective, it's generally useful not use it as a
>pattern. In such a case, when informing the symbol
>transliteration, press the ESC key once before training that
>symbol (or press the BAD button). The OCR will mark that symbol
>as "bad".
>
>The behaviour of the "alphabet" button is as follows: by default
>it is in the state "other". If the current symbol is trained as a
>latin letter ('a', 'b', 'c', etc), this property is automatically
>set to "latin". If the current symbol is trained as a decimal
>digit ('0', '1', etc), this property is automatically set to
>"number". If the button state is manually set to "greek" and a
>letter is input from a latin keyboard, it will be automatically
>mapped to the corresponding greek letter ("a" to "alpha", "b" to
>"beta", etc). Note that the alphabet button circulates only those
>alphabets selected on the "Alphabets" menu. By now, Clara OCR
>does not include mappings for other alphabets.
>
>The "pattern types" button presents the classification of the
>symbol regarding the font types (Clarendom, Times, etc) and sizes
>(9pt, 10pt, etc) found on the book. It's not mandatory to
>classify the patterns, and there is some preliminar code to
>perform this classification automatically. However, it's
>currently expected to be performed manually, if desired. For
>instance: first train some symbols, all of same type and
>size. All just created patterns are put on type 0. Then use the
>"set pattern type" on Edit menu to change their types from 0 to
>some other at your choice.
>
>
>Saving the session
>------------------
>
>Before going further, it's important to know how to save your
>work. The file menu contains one item labelled "save
>session". When selected, it will create or overwrite three files
>on the working directory: "patterns", "acts" and "page.session",
>where "page" is the name of the file currently loaded, without
>the "pbm" or "pgm" tag (in out example, "imre"). So, to remove
>all data produced by OCR sessions, remove manually the files
>"*.session", "patterns" and "acts".
>
>Note that the files "patterns" and "acts" are shared by all PBM
>or PGM pages, so a symbol trained from one page is reused on the
>other pages. The ".session" files however are per-page. Pages
>with the same graphic characteristics, and only them, must be put
>on one same directory, in order to share the same patterns.
>
>When the "quit" option of the "File" menu is selected, the OCR
>prompts the user for saving the session (answer pressing the key
>"y" or "n"), unless there are no unsaved changes.
>
>
>
>OCR steps
>---------
>
>The OCR process is divided into various steps, for instance
>"classification", "build", etc. These steps are acessible clicking
>the mouse button 3 over the OCR button. Each one can be started
>independently and/or repeated at any moment. In fact, the more
>you know about these steps, the better you'll use them.
>
>Clicking the "OCR" button with the mouse button 1, all steps will
>be started in sequence. The "OCR" button remains on the
>"selected" state while some step is running.
>
>Yet we won't cover this stuff in the tutorial, a basic knowledge
>on what each step perform is required for fine-tuning Clara OCR.
>The tuning is an interactive effort where the usage of the
>heuristics alternates with training and revision, guided by the
>user experience and feeling.
>
>
>Classification
>--------------
>
>After training some symbols, we're ready to apply the just
>acquired knowledge to deduce the transliteration of non-trained
>symbols. For that, Clara OCR will compare the non-trained symbols
>with those trained ("patterns"). Clara OCR offers nice visual
>modes to present the comparison of each symbol with each
>pattern. To activate the visual modes, enter the View menu and
>select (for instance) the "show comparisons" option.
>
>Now start the "classification" step (click the mouse button 3
>over the OCR button and select the "classification" item) and
>observe what happens. Depending on your hardware and on the size
>of the document, this operation may take long to complete
>(e.g. 5 minutes). Hopefully it'll be much faster (say, 30
>seconds).
>
>When the classification finishes, observe that some nontrained
>symbols became black. Each such symbol was found similar to some
>pattern. Select one black symbol, and Clara will draw a gray
>ellipse around each class member (except the selected symbol,
>identified by the black graphic cursor). You can switch off this
>feature unselecting the "Show current class" item on the "View"
>menu.
>
>In some cases, Clara will classify incorrectly some symbols. For
>instance, a defective "e" may be classified as "c". If that
>happens, you can inform Clara about the correct transliteration
>of that symbol training it as explained before (in this example,
>select the symbol and press "e"). This action will remove that
>symbol from its current class, and will define a new class,
>currently unitary and containing just that symbol.
>
>
>Note about how Clara OCR classification works
>---------------------------------------------
>
>The usual meaning of "classification" for OCRs is to deduce for
>each symbol if it is a letter "a" or the letter "b", or a digit
>"1", etc. As the total number of different symbols is small (some
>tenths), there will be a small quantity of classes.
>
>However, instead of classifying each symbol as being the letter
>"a", or the digit "1", or whatever, Clara OCR builds classes of
>symbols with similar shapes, not necessarily assigning a
>transliteration for each symbol. So as sometimes the bitmap
>comparison heuristics consider two true letters "a" dissimilar
>(due to printing differences or defects), the Clara OCR
>classifier will brake the set of all letters "a" in various
>untransliterated subclasses.
>
>Therefore, the classification result may be a much larger number
>of classes (thousands or more), not only because of those small
>differences or defects, but also because the classification
>heuristics are currently unable to scale symbols or to "boldfy"
>or "italicize" a symbol.
>
>Note that each untransliterated subclass of letters "a" depends
>on a punctual human revision effort to become transliterated
>(trained). This is not an absurd strategy, because the revision
>of each subset corresponds to part of the unavoidable human
>revision effort required by any real-life digitalization
>project. This is one of the principles that make possible to see
>Clara OCR not as a traditional OCR, but as a productivity tool
>able to reduce costs. Anyway, we expect to the future more
>improvements on the Clara OCR classifier, in order to lessen the
>number of subclasses created.
>
>
>Building the output
>-------------------
>
>Now we're ready to build the OCR output. Just start the
>"build" step. The action performed will be basically
>to detect text words and lines, and output the transliterations,
>trained or deduced, of all symbols. The output will be presented
>on the "PAGE (output)" window.
>
>Each character on the "PAGE (output)" window behaves like a
>HTML hyperlink. Click it to select the current symbol both
>on the "PAGE" window and on the "PAGE (symbol)" window. Note
>that the transliteration of unknow symbols is substituted by
>their internal IDs (for instance "[133]").
>
>The result of the word detection heuristic can be visualized
>checking the "show words" item on the "View" menu.
>
>
>Handling broken symbols
>-----------------------
>
>Remark: As to version CLARA_VERSION the merging heristics are only
>partially implemented, and in most cases they won't produce any effect.
>
>The build heuristics also try to merge the pieces of broken
>symbols, just like the "u", the "h" and the "E" on the figure
>(observe the absent pixels). Some letters have thin parts, and
>depending on the paper and printing quality, these parts will
>brake more or less frequently.
>
>
>                 XXX            XXXXXXXXXXX
>                  XX             XXX      X
>                  XX             XXX
>                  XX             XXX
>    XXX   XXX     XX   XXX       XXX     X
>     XX    XX     XXX     X      XXX  XXXX
>     XX    XX     XX      XX     XXX     X
>     XX    XX     XX      XX     XXX
>     XX    XX     XX      XX     XXX
>     XX    XX     XX      XX     XXX      X
>      XX  XXXX   XXXX     XXX   XXXXXXXXXXX
>
>
>Clara OCR offers three symbol merging heuristics:
>geometric-based, recognition-based and learned. Each one may be
>activated or deactivated using the "tune" tab.
>
>Geometric merging applies to fragments on the interior of the
>symbol bounding box, like the "E" on the figure, and to some other
>cases too.
>
>The recognition merging searches unrecognized
>symbols and, for each one, tries to merge it with some
>neighbour(s), and checks if the result becomes similar to some
>pattern.
>
>Finally, learned merging will try to reproduce the
>cases trained by the user. To train merging, just select the
>symbol using the mouse button 1
>(say, the left part of the "u" on the figure), click the mouse
>button 3 on the fragment (the right part of the "u"), and select
>the "merge with current symbol" entry. On the other hand, the
>"disassemble" entry may be used to break a symbol into its
>components.
>
>Remark: do not merge the "i" dot with the "i" stem. See the
>subsection "handling accents" for details.
>
>Handling accents
>----------------
>
>Now let's talk about accents.
>
>As a general rule, Clara OCR does not consider accents as parts
>of letters, so merging does not apply to accents. Accents are
>considered individual symbols, and must be trained
>separately. The "i" dot is handled as an accent. Clara OCR will
>compose accents with the corresponding letters when generating
>the output. The exception is when the accent is graphically
>joined to the letter:
>
>           XXX
>           XX          XXX
>          XX           XX
>                      XX
>       XXXX         XXXX
>     XX    XX     XX    XX
>    XX      XX   XX      XX
>    XXXXXXXXXX   XXXXXXXXXX
>    XX           XX
>    XX           XX
>     XX    XX     XX    XX
>       XXXX         XXXX
>
>
>In the figure we have two samples of "e" letter with acute
>accent. In the first one, the accent is graphically separated
>from the letter. So the accent transliteration will be trained or
>deduced as being "'", the letter transliteration
>will be trained or deduced as beig "e". When generating the output,
>Clara OCR will compose them as the macro "\'e" (or as the ISO
>character 233, as soon as we provide this alternative behaviour).
>
>On the second case the accent isn't graphically separable from
>the letter, so we'll need to train the accented character as the
>corresponding ISO character (code 233) or as the macro "\'e". As
>the generation of accented characters depend on the local X
>settings, the "Emulate deadkeys" item on the "Options" menu may
>be useful in this case. It will enable the composition of accents
>and letters performed directly by Clara OCR (like Emacs
>iso-accents-mode feature).
>
>
>Browsing the book font
>----------------------
>
>As explained earlier, trained symbols become patterns (unless you
>mark it "bad"). The collection of all patterns is called "book
>font" (the term "book" is to distinguish it from the GUI
>font). Clara OCR stores all pattern in the "patterns" file on the
>work directory, when the "save session" entry on the "File" menu
>is selected.
>
>Clara OCR itself can choose the patterns and populate the book
>font. To do so, just select the "Build the font automatically"
>item on the "tune" tab, and classify the symbols.
>
>To browse the patterns, click the "pattern" tab one or more times
>to enter the "Pattern (list)" window. The "PATTERN (list)" mode
>displays the bitmap and the properties
>of each pattern in a (perhaps very long) form.
>Click the "zoom" button to
>adjust the size of the pattern bitmaps. Use the scroolbar or
>the Next (Page Down) or Previous (Page Up) keys to navigate. Use
>the sort options on the "Edit" menu to change the presentation order.
>
>Now press the "pattern" tab again to reach the "Pattern" window. It
>presents the "current" pattern with detailed properties. try
>activating the "show web clip" option on the "View" menu to
>visualize the pattern context. The left and
>right arrows will move to the previous and to the next patterns. To
>train the current pattern (being exhibited on the "Pattern" window),
>just press the key corresponding to its transliteration (Clara will
>automatically move to the next pattern) or fill the
>input field. There is no need to press ENTER to submit the input
>field contents.
>
>
>Useful hints
>------------
>
>If the GUI becomes trashed or blank, press C-l to redraw it.
>
>By now, the GUI do not support cut-and-paste. To save to a file
>the contents of the "PAGE (list)" window, use the "Write report"
>item on the "File" menu.
>
>The "OCR" button will enter "pressed" stated in some unexpected
>situations, like during dialogs. This behaviour will be fixed
>soon.
>
>The "STOP" button do not stop immediately the OCR operation in
>course (e.g. classification). Clara OCR only stops the operation
>in course in "secure" points, where all data structures are
>consistent.
>
>The OCR output is automatically saved to the file page.html (or
>page.txt if the option -o was used), where "page" is the name of
>the currently loaded page, without the "pbm" or "pgm" tag. This
>file is created by the "generate output" step on the menu that
>appears when the mouse button 3 is pressed over the OCR button.
>
>Some OCR steps are currently unfinished and perform no
>action at all.
>
>
>Fun codes
>---------
>
>Clara OCR "fun codes" are similar to videogame "codes" (for those
>who have never heard about that, videogame "codes" are special
>sequences of mouse or key clicks that make your player
>invulnerable, or obtain maximum energy, or perform an unexpected
>action, etc).
>
>The difference is that Clara OCR "fun codes" are not secret
>(videogame "codes" are normally secret and very hard to discover
>by chance). Clara OCR contains no secret feature. Fun codes are
>intended to be used along public presentations. By now there is
>only one fun code: just click one or more times the banner on the
>welcome window to make it scroll.
>
>
>*/
#line book.c:1896 (book)
>/* (book)
>
>Supported Alphabets
>-------------------
>
>Clara OCR focuses the Latin Alphabet ("a", "b", "c", ...),
>used by most European languages, and the decimal digits
>("0", "1", "2", ...), but we're trying to support as many
>alphabets as possible.
>
>To say that Clara OCR supports a given alphabet means that
>Clara OCR
>
>(a) is able to be trained from the keyboard for the symbols of
>that alphabet, eventually applying some transliteration from that
>alphabet to latin. For instance, when OCRing a greek text, if the
>user presses the latin "a" key (assuming that the keyboard has
>latin labels), Clara is expected to train the current symbol as
>"alpha".
>
>(b) knows the vertical alignment of each letter of that alphabet,
>for instance, knows that the bottom of an "e" is aligned at the
>baseline;
>
>(c) knows which letters accept or require which signs (accents
>and others, like the dot found on "i" and "j");
>
>(d) contains code to help avoiding common mistakes, like
>recognizing "e" as "c", "l" as "1", etc.
>
>To say that Clara OCR supports a given alphabet does not
>necessarily mean that Clara OCR
>
>(a) knows some particular encoding (ISO-8859-X, Unicode, etc)
>for that alphabet;
>
>(b) contains or is able to use fonts for that alphabet to
>display the OCR output on the PAGE (OUTPUT) window.
>
>Even ignoring the standard encondings for one given
>alphabet (e.g. ISO-LATIN-7 for Greek), Clara eventually
>will be able to produce output using TeX macros, like
>{\Alpha}.
>
>*/
#line book.c:1942 (devel)
>/* (devel)
>
>Introducing the source code
>---------------------------
>
>This Guide is a collection of entry points to the Clara OCR
>source code. Some notes explain punctual details about how this
>or that feature was implemented. Others are higher-level
>descriptions about how one entire subsystem works.
>
>Language and environment
>------------------------
>
>Clara OCR is written in ANSI C (with some GNU extensions) and
>requires the services of the C library and the Xlib. The
>development is using 32-bit Intel GNU/Linux (various different
>distributions), GCC, Gnu Make, Bash, XFree86 and Perl 5 (required
>for producing the documentation).
>
>Modularization
>--------------
>
>Clara source code started, of course, as being one only file
>named clara.c. At some point we divided it into smaller
>pieces. Currently there are 18 files:
>
>  book.c     .. Documentation only
>  build.c    .. The function build
>  clara.c    .. Startup and OCR run control
>  cml.c      .. ClaraML dumper and recover
>  common.h   .. Common declarations
>  consist.c  .. Consistency tests
>  event.c    .. GUI initialization and event handler
>  gui.h      .. Declarations that depend on X11
>  html.c     .. HTML generation and parse
>  pattern.c  .. Book font stuff
>  pbm2cl.c   .. Import PBM
>  pgmblock.c .. grayscale loading and blockfinding
>  preproc.c  .. internal preprocessor
>  redraw.c   .. The function redraw
>  revision.c .. Revision procedures
>  skel.c     .. Skeleton computation
>  symbol.c   .. Symbol stuff
>  welcome.c  .. Welcome stuff
>
>Along this document we'll not refer these files, but the
>identifiers (names of functions and variables).
>
>Note that there are only two headers: common.h and gui.h. It's
>complex to maintain one header for each module. Most functions
>are not prototyped, but we intend to prototype all them in the
>near future.
>
>
>Security notes
>--------------
>
>Concerning security, the following criteria is being used:
>
>1. string operations are generally performed using services that
>accept a size parameter, like snprint or strncpy, except when the code
>itself is simple and guarantees that a overflow won't occur.
>
>2. The CGI clara.pl invokes write privileges through sclara, a program
>specially written to perform only a small set of simple operations
>required for the operation of the Clara OCR web interface.
>
>The following should be done:
>
>1. Memory blocks should be cleared before calling free().
>
>
>Runtime index checking
>----------------------
>
>A naive support for runtime index checking is provided through the
>macro checkidx. This checking is performed only if the code is
>compiled with the macro MEMCHECK defined and the command-line switch
>'-X 1' is used.
>
>In fact, only those points on the source code where the macro checkidx
>is explicitly used will perform index checking. We've added calls to
>checkidx on some critical functions due to its complexity, or because
>segfaults were already were detected there.
>
>Background operation
>--------------------
>
>Clara OCR decides at runtime if the GUI will be used or not. So
>even when using Clara OCR in batch mode (-b command-line switch),
>linking with the X libraries is required.
>
>When the -b command-line switch is used, Clara OCR just won't
>make calls to X services. The source code tests the flag
>"batch_mode" before calling X services. So it won't create the
>application window on the X display, and automatically starts a
>full OCR operation on all pages found (as if the "OCR" button was
>pressed with the "work on all pages" option selected).  Upon
>completion, Clara OCR will exit.
>
>
>Synchronization
>---------------
>
>
>
>Execution model
>---------------
>
>In order to allow the GUI to refresh the application window while
>one OCR run is in course, Clara does not use multiple
>threads. The main function alternates calls to xevents() to
>receive input and to continue_ocr() to perform OCR. As the OCR
>operations may take long to complete, a very simple model was
>implemented to allow the OCR services to execute only partially.
>
>Such services (for instance load_page()) accept a "reset" parameter
>to allow resetting all static data, and they're expected to
>return 0 when finished, or nonzero otherwise. Therefore, a call to
>such services must loop until completion. The continue_ocr() calls
>the OCR steps using this model, and some OCR steps call other
>services (like load_page()) that implement this model too.
>
>
>
>
>Resetting
>---------
>
>XML support
>-----------
>
>We decided to use XML because of the facilities of using
>non-binary encodings to store, analyse, change and transmit
>information, and also because XML is a standard. Currently we do
>not have DTDs, and until now we didn't try to load, using the
>Clara parser, XML code not produced by Clara itself.
>
>
>The GUI
>-------
>
>
>Main characteristics
>--------------------
>
>1. Clara OCR GUI uses only 5 colors: white, gray, darkgray,
>verydarkgray and black. The RGB value for each one is
>customizable at startup (-c command-line option). On truecolor
>displays, graymaps are displayed using more graylevels than the 5
>listed above.
>
>2. The X I/O is not buffered. Buffered X I/O is implemented but
>it's not being used.
>
>3. Only one X font is used for all needs (button lables, menu
>entries, HTML renderization, and messages).
>
>4. Asynchronous refresh. The OCR operations just set the redraw
>flags (redraw_button, redraw_wnd, redraw_int, etc) and let the
>redraw() function make its work.
>
>5. No toolkit is used. The graphic code is very specific to
>Clara, and it was not written to be reusable. So it's very
>small. The disadvantage of this approach is that Clara look and
>behaviour will be slightly different from the typical ones found
>on popular environments like GNOME or KDE.
>
>
>
>The Clara API
>-------------
>
>
>*/
#line book.c:2118 (book)
>/* (book)
>
>Building the book font
>----------------------
>
>Patterns are selected symbols from the book. They're obtained
>from manual training, or from automatic selection. The patterns
>are used to deduce the transliteration of the unknown symbols by
>the bitmap comparison heuristics. In other words, the OCR
>discovers that one symbol is the letter "a" or the digit "1"
>comparing it with the patterns.
>
>The book font is the collection of all patterns. The term "book
>font" was chosen to make sure that we're not talking about the X
>font used by the GUI. The book font is stored on a separate file
>("patterns", on the work directory). Clara OCR classifies the
>patterns into "types", one type for each printing font. By now,
>most of this work must be done manually. Someday in the future,
>the auto-tuning features and the pre-build customizations will
>hopefully make this process less painful.
>
>So, before OCRing one book, it's convenient to observe the
>different fonts used. In our case, we have three fonts (the
>quotations refer the page 5.pbm):
>
>    Unknown Latin 9pt         ("Todos sao iguais...")
>    Unknown Latin 9pt bold    ("Art. 5")
>    Unknown Latin 8pt italic  (footings)
>
>It's not mandatory to exactly identify each font by its "correct"
>name or style or size (Roman, Arial, Courier, etc). In our case,
>we've chosen the labels above ("Unknown Latin 9pt" and the
>others). These labels can be manually entered using the PATTERN
>(TYPES) tab, one "type" for each "font". So we'll have 3 "types",
>and, for each one, various parameters can be manually
>informed. At least the alphabet must be informed. In fact, the
>PATTERN (TYPES) tab allows structuring very carefully all fonts
>used along the book. Even some intrincated details, like the
>classification techniques that can be used for each symbol, can
>be set.
>
>Now we can select some patterns from the pages 143-l.pbm and
>143-r.pbm. Try:
>
>    $ cd /home/clara/books/MBB/pbm
>    $ clara &
>
>Load the page 143-l.pbm. Observe the symbols, select a nice one
>using the mouse button 1 or the arrows (say, a letter "a", small)
>and train it pressing the corresponding key (the "a" key). Repeat
>this process for various symbols, all from one same type (so do
>not mix bold with non-bold, etc). The entered patterns belong by
>default to "type 0". The "Set pattern type" entry of the Edit
>menu can be used to move all "type 0" patterns to some other type
>(1, 2 or 3 in our case). To display the letters and digits for
>which few or no samples are trained, click the mouse right button
>over the PAGE tab and select "Show pattern type". This way, one
>can complete all fonts used along the book.
>
>At this point, the "Auto-classify" feature (Edit menu) may be
>quite useful. When on, Clara OCR will apply the just trained
>pattern to solve all unknown symbols, so after training an "a",
>only those "a" letters dissimilar to that trained will remain
>unknown (grayed).
>
>Now save the session (menu "File"), exit Clara OCR (menu "File"),
>and enter Clara OCR again using the same commands above. Try to
>load one file and/or to observe the patterns on the tabs PATTERN,
>PATTERN (list), TUNE (SKEL), etc. This is a good way to
>experience that Clara OCR is started and exited many times along
>the duration of one OCR project.
>
>The last remark in this subsection: instead of the just described
>manual pattern selection, Clara OCR is able to select by itself
>the patterns to use from the pages. In order to use this feature,
>after selecting the checkbox "Build the bookfont automatically"
>(TUNE tab), classify the symbols (just press the OCR button using
>the mouse button 1, or press the mouse button 3 over it and
>select the "classify" item). However, the current recommendation
>is to prefer the manual selection of patterns, at least as a
>first step.
>
>*/
#line book.c:2202 (book)
>/* (book)
>
>Reference of the Clara GUI
>--------------------------
>
>In this section, the Clara application window will be described
>in detail, both to document all its features and to define the
>terminology.
>
>
>
>The application window
>----------------------
>
>The application window is divided into three major areas: the
>buttons ("zoom", "OCR", "stop", etc) the "plate" (right),
>including the tabs ("page", "symbol" and "font"), and one or more
>"document windows" inside the plate.
>
>We say "document window" because each window is exhibiting one
>"document". This "document" may be the scanned page (PAGE
>window), the current OCR output for this page (PAGE OUTPUT
>window), the symbol form (PAGE SYMBOL window), the GPL (GPL
>window) and so on. However, we'll refer the document windows
>merely as "windows".
>
>Around each window there are two scrollbars. On the botton of the
>application window there is a status line. On the top there is
>a menu bar (fully documented on the section "Reference of the
>menus").
>
>
>    +-----------------------------------------------+
>    | File Edit OCR ...                             |
>    +-----------------------------------------------+
>    | +--------+     +----+ +--------+ +-------+    |
>    | |  zoom  |     |page| |patterns| | tune  |    |
>    | +--------+   +-+    +-+        +-+       +-+  |
>    | +--------+   | +-------------------------+ |  |
>    | |  zone  |   | |                         | |  |
>    | +--------+   | |                         | |  |
>    | +--------+   | |                         | |  |
>    | |  OCR   |   | |        WELCOME TO       | |  |
>    | +--------+   | |                         | |  |
>    | +--------+   | |    C L A R A    O C R   | |  |
>    | |  stop  |   | |                         | |  |
>    | +--------+   | |                         | |  |
>    |      .       | |                         | |  |
>    |      .       | |                         | |  |
>    |              | |                         | |  |
>    |              | |                         | |  |
>    |              | +-------------------------+ |  |
>    |              +-----------------------------+  |
>    |                                               |
>    | (status line)                                 |
>    +-----------------------------------------------+
>
>
>Tabs and windows
>----------------
>
>Three tabs are oferred, and each one may operate in one or more
>"modes". For instance, pressing the PATTERN tab many times will
>circulate two modes: one presenting the windows "pattern" and
>"pattern (props)" and another with the window "pattern
>(list)".
>
>On each tab, Clara OCR displays on the plate one or more
>windows. Each such window is called a "document window" to
>distinguish them from the application window. Each such window
>is supposed to be displaying a portion of a larger document, for
>instance
>
>    The scanned page (graphic)
>    The OCR output (text)
>    The list of pages (text)
>    The list of patterns (text)
>    The symbol description (text)
>
>Unless the user hides them, two scrollbars are displayed for each
>document window, one horizontal and one vertical. On each one, a
>cursor is drawn to show the relative portion of the full document
>currently visible ont the display.
>
>All available tabs and the modes for each one are listed
>below. The numbers (1, 2, etc) are only to make easier to
>distinguish one mode from the others. There is no effective
>association between the modes and the numbers.
>
>     tab      mode      windows
>    -------------------------------
>
>               1       WELCOME
>
>               2       GPL
>
>               3       PATTERN_ACTION
>
>    page       4       PAGE_LIST
>
>               5       PAGE
>                       PAGE_OUTPUT
>                       PAGE_SYMBOL
>
>               6       PAGE_FATBITS
>                       PAGE_MATCHES
>
>    pattern    7       PATTERN
>
>               8       PATTERN_LIST
>
>               9       PATTERN_TYPES
>
>    tune      10       TUNE
>
>              11       TUNE_PATTERN
>                       TUNE_SKEL
>
>              11       TUNE_ACTS
>
>
>Note that the windows WELCOME and GPL have no corresponding
>tab. When these windows are displayed, there is no active
>tab. Except in these cases, the name of the current window is
>always presented as the label of the active tab.
>
>The Alphabet Map
>----------------
>
>When the "Show alphabet map" option of the "View" menu is selected,
>the GUI will include an alphabet map between the buttons and the
>plate. This map presents all symbols from the current alphabet. The
>current alphabet is selected using the alphabet button. The alphabet
>button circulates all alphabets selected on the "Alphabets" menu.
>
>Clara OCR offers an initial support for multiple alphabets. To become
>useful, it needs more work. The alphabet map currently does not offer
>any functionality. For some alphabets (Cyrillic and Arabic) the
>alphabet map is disabled on the source code due to the large alphabet
>size. Currently Clara OCR does not contain bitmaps for displaying
>Katakana.
>
>
>Reference of the menus
>----------------------
>
>Most menus are acessible from their labels menu bar (on the top of the
>application window). The labels are "File", "Edit", etc. Other menus
>are presented when the user clicks the mouse button 3 on some special
>places (for instance the button "OCR"). Let's describe all menus and
>their entries.
>
>*/
#line book.c:2356 (devel)
>/* (devel)
>
>Geometry of windows
>-------------------
>
>The current window is informed through the CDW global variable
>(set by the setview function). The variable CDW is an index for
>the dw array of dwdesc structs. Some macros are used to refer the
>fields of the structure dw[CDW]. The list of all them can be
>found on the headers under the title "Parameters of the current
>window".
>
>The portion of the document being displayed is defined by the
>macros X0, Y0, HR and VR, where (X0,Y0) is the top left and HR
>and VR are the width and heigth, measured in pixels (graphic
>documents) or characters (text documents):
>
>
>         X0  X0+HR-1
>         |     |
>    +----+-----+--+
>    |             |
>    |             |
>    |    +-----+  +- Y0
>    |    |     |  |
>    |    |     |  |
>    |    |     |  |
>    |    +-----+  +- Y0+VR-1
>    |             |
>    |             |
>    |             |
>    |             |
>    |             |
>    |             |
>    +-------------+
>     The document
>
>
>Regarding the application window, the document window is a
>portion of the plate, defined by DM, DT, DW and DH, where (DM,DT)
>is the top left and DW and DH are the width and heigth measured
>in display pixels.
>
>
>          DM              DM+DW-1
>          |                 |
>    +-----+-----------------+----+
>    |                            |
>    |                            |
>    |                            |
>    |     +-----------------+    +- DT
>    |     |                 | |  |
>    |     |                 | X  |
>    |     |                 | X  |
>    |     |    Document     | X  |
>    |     |     window      | |  |
>    |     |                 | |  |
>    |     |                 | |  |
>    |     |                 | |  |
>    |     |                 | |  |
>    |     +-----------------+    +- DT+DH-1
>    |      -----XXXXXXXXXXX-     |
>    |                            |
>    |                            |
>    +----------------------------+
>         Application window
>
>
>The rectangle (X0,Y0,HR,VR) from the document is exhibited into
>the display rectangle (DM,DT,DW,DH). When displaying the scanned
>page, the reduction factor RF applies. Each square RFxRF of
>pixels from the document will be mapped to one display pixel.
>When displaying the scanned page in fat bit mode, each document
>pixel will be mapped to a square ZPSxZPS of display pixels, and a
>grid will be displayed too.
>
>
>Scrollbars
>----------
>
>The scrollbars inform the relative portion of the document being
>exhibited. The viewable region of the document (in the sense just
>defined) is defined by X0, Y0, HR and VR:
>
>              Y0    Y0+HR-1
>
>         +----+-------+-------+ - 0
>         |                    |
>      X0 +    +-------+       |
>         |    |       |       |
>         |    |       |       |
>         |    |       |       |
>         |    |       |       |
> X0+VR-1 +    +-------+       |
>         |                    |
>         |                    |
>         |                    |
>         |                    |
>         +--------------------+ - GRY-1
>
>         |                    |
>         0                   GRX-1
>
>The variables GRX and GRY contain the total width and height of
>the full document, measured in pixels. The interpretation of the
>contents of the variables X0, Y0, HR and VR is not simple. In some
>cases, they will contain values measured in pixels. In other cases,
>in characters. The variables HR and VR define the size of the
>window. However, in some cases this size is the size
>from the viewpoint of the document and, in others, of the display
>(the difference is a reduction factor).
>
>            +------------+  -
>            |            |  |
>            |            |  |
>            |            |  X
>            |            |  X
>            |            |  X
>            |            |  |
>            |            |  |
>            +------------+  -
>
>            |---XXXX-----|
>
>
>Note that the parameters X0, Y0, HR, VR, GRX and GRY are macros
>that refer the corresponding fields of the structure dw[CDW],
>that stores the parameters of the current DW.
>
>
>Displaying bitmaps
>------------------
>
>The Bitmaps on HTML windows and on the PAGE window are exhibited
>in "reduced" fashion (a square RFxRF of pixels from the bitmap is
>mapped to one display pixel). If RF=1, then each bitmap pixel
>will map to one display pixel.
>
>The windows PATTERN, PAGE_FATBITS, and PAGE_MATCHES exhibit
>bitmaps in "zoomed" mode (one bitmap pixel maps to a ZPSxZPS
>square of display pixels). In this case a grid is displayed to
>make easier to distinguish each pixel. The variables GW and GS
>contain the grid width and the "grid separation" (GS=ZPS+GW).
>
>                   ZPS     GS              GW
>                |<---->|<----->|   --->||<---
>
>               ++------++------++------++----
>               ++------++------++------++----
>               ||      ||      ||      ||
>               ||      ||      ||      ||
>               ||      ||      ||      ||
>               ++------++------++------++----
>               ++------++------++------++----
>               ||      ||      ||      ||
>               ||      ||      ||      ||
>               ||      ||      ||      ||
>
>
>Note that the parameters RF, GS and GW are macros that refer the
>corresponding fields of the structure dw[CDW], that stores the
>parameters of the current DW.
>
>
>Auto-submission of forms
>------------------------
>
>The Clara OCR GUI tries to apply immediately all actions taken by
>the user. So the HTML forms (e.g. the PATTERN window) do not
>contain SUBMIT buttons, because they're not required (some forms
>contain a SUBMIT button disguised as a CONSIST facility, but this
>is just for the user's convenience).
>
>The editable input fields make auto-submission mechanisms a bit
>harder, because we cannot apply consistency tests and process the
>form before the user finishes filling the field, so
>auto-submission must be triggered on selected events. The
>triggers must be a bit smart, because some events must be
>attended before submission (for instance toggle a CHECKBOX),
>while others must be attended after submission (for instance
>changing the current tab). So auto-submission must be carefully
>studied. The current strategy follows:
>
>a. When the window PAGE (symbol) or the window PATTERN is
>visible, auto-submit just after attending the buttons that change
>the current symbol/pattern data (buttons BOLD, ITALIC, ALPHABET
>or PTYPE).
>
>b. When the window PAGE (symbol) or the window PATTERN is
>visible, auto-submit just before attending the left or right
>arrows.
>
>c. When the user presses ENTER and an active input field exists,
>auto-submit.
>
>d. Auto-submit as the first action taken by the setview service,
>in order to flush the current form before changing the current
>tab or tab mode.
>
>e. Auto-submit just after opening any menu, in order to flush
>data before some critic action like quitting the program or
>starting some OCR step.
>
>f. Auto-submit just after attending CHECKBOX or RADIO buttons.
>
>Auto-submission happens when the service auto_submit_form is
>called, so it's easy to locate all triggering points (just search
>the string auto_submit_form). This service takes no action when
>the current form is unchanged.
>
>The Clara API
>-------------
>
>This section describes the variables and functions exported by
>Clara OCR for extensionability purpuses. Note that Clara OCR
>currently does not have an interface for extensions. The first
>such interface planned to be added will use the Guile
>interpreter, available from the GNU Project.
>
>*/
#line book.c:2577 (all)
>/* (all)
>
>AVAILABILITY
>------------
>
>Clara OCR is free software. Its source code is distributed under
>the terms of the GNU GPL (General Public License), and is
>available at CLARA_HOME. If you don't know what is the GPL,
>please read it and check the GPL FAQ at
>http://www.gnu.org/copyleft/gpl-faq.html. You should have
>received a copy of the GNU General Public License along with this
>software; if not, write to the Free Software Foundation, Inc., 59
>Temple Place - Suite 330, Boston, MA 02111-1307, USA. The Free
>Software Foundation can be found at http://www.fsf.org.
>
>
>CREDITS
>-------
>
>Clara OCR was written by Ricardo Ueda Karpischek. Giulio Lunati
>wrote the internal preprocessor. Clara OCR includes bugfixes
>produced by other developers. The Changelog
>(http://www.claraocr.org/CHANGELOG) acknowledges all them (see
>below). Imre Simon contributed high-volume tests, discussions
>with experts, selection of bibliographic resources, propaganda
>and many ideas on how to make the software more useful.
>
>Ricardo authored various free materials, some included (at least)
>in Conectiva, Debian, FreeBSD and SuSE (the verb conjugator
>"conjugue", the ispell dictionary br.ispell and the proxy
>axw3). He recently ported the EiC interpreter to the Psion 5
>handheld and patched the Xt-based vncviewer to scale framebuffers
>and compute image diffs. Ricardo works as an independent
>developer and instructor. He received no financial aid to develop
>Clara OCR. He's not an employee of any company or organization.
>
>Imre Simon promotes the usage and development of free
>technologies and information from his research, teaching and
>administrative labour at the University.
>
>Roberto Hirata Junior and Marcelo Marcilio Silva contributed
>ideas on character isolation and recognition. Richard Stallman
>suggested improvements on how to generate HTML output. Marius
>Vollmer is helping to add Guile support. Jacques Le Marois helped
>on the announce process. We acknowledge Mike O'Donnell and Junior
>Barrera for their good criticism. We acknowledge Peter Lyman for
>his remarks about the Berkeley Digital Library, and Wanderley
>Antonio Cavassin, Janos Simon and Roberto Marcondes Cesar Junior
>for some web and bibliographic pointers. Bruno Barbieri Gnecco
>provided hints and explanations about GOCR (main author: Jorg
>Schulenburg). Luis Jose Cearra Zabala (author of OCRE) is gently
>supporting our tentatives of using portions of his code. Adriano
>Nagelschmidt Rodrigues and Carlos Juiti Watanabe carefully tried
>the tutorial before the first announce. Eduardo Marcel Macan
>packaged Clara OCR for Debian and suggested some
>improvements. Mandrakesoft is hosting claraocr.org. We
>acknowledge Conectiva and SuSE for providing copies of their
>outstanding distributions. Finally, we acknowledge the late Jose
>Hugo de Oliveira Bussab for his interest in our work.
>
>Adriano Nagelschmidt Rodrigues donated a 15" monitor.
>
>The fonts used by the "view alphabet map" feature came from
>Roman Czyborra's "The ISO 8859 Alphabet Soup" page at
>http://czyborra.com/charsets/iso8859.html.
>
>The names cited by the CHANGELOG (and not cited before) follow
>(small patches, bug reports, specfiles, suggestions,
>explanations, etc).
>
>Brian G. (win32),
>Bruce Momjian,
>Charles Davant (server admin),
>Daniel Merigoux,
>De Clarke,
>Emile Snider (preprocessor, to be released),
>Erich Mueller,
>Franz Bakan (OS/2),
>groggy,
>Harold van Oostrom,
>Ho Chak Hung,
>Jeroen Ruigrok,
>Laurent-jan,
>Nathalie Vielmas,
>Romeu Mantovani Jr (packager),
>Ron Young,
>R P Herrold,
>Sergei Andrievskii,
>Stuart Yeates,
>Terran Melconian,
>Thomas Klausner (NetBSD),
>Tim McNerney,
>Tyler Akins.
>
>*/
#line book.c:2673 (faq)
>/* (faq)
>
>WELCOME
>-------
>
>These are the Clara OCR Frequently Asked Questions. They're
>useful for a first contact with Clara OCR. If you're looking for
>information on how to use Clara OCR, please try the Clara OCR
>Tutorial instead. Clara OCR can be found at CLARA_HOME.
>
>CONTENTS
>--------
>
>What is Clara OCR?
>Why is Clara a "cooperative OCR"?
>Is Clara OCR Free? Open Source?
>Is Clara OCR a GNU program?
>On which platforms does Clara OCR run?
>Does Clara OCR have a command-line interface?
>Does Clara OCR run on KDE? GNOME?
>Which languages are supported by Clara OCR?
>Does Clara OCR support Unicode?
>Is Clara OCR omnifont?
>How does Clara differ from other OCRs?
>What is PBM/PGM/PPM/PNM?
>How can I scan paper documents using Clara OCR?
>I've tried Clara OCR, but the results disappointed me
>How can I get support on Clara OCR?
>Does Clara OCR induce to Copyright Law infringements?
>How can I help the Clara OCR development effort?
>
>
>
>What is Clara OCR?
>------------------
>
>Clara is an OCR program. OCR stands for "Optical Character
>Recognition". An OCR program tries to recognize the characters
>from the digital image of a paper document. The name Clara stands
>for "Cooperative Lightweight chAracter Recognizer".
>
>
>Why is Clara a "cooperative OCR"?
>---------------------------------
>
>Clara is a cooperative OCR because it offers an web interface for
>training and revision, so these tasks can benefit from the
>revision effort of many people across the Internet. However,
>Clara OCR also offers a powerful X-based GUI for standalone
>usage.
>
>
>Is Clara OCR Free? Open Source?
>-------------------------------
>
>Clara OCR is distributed within the terms of the Gnu Public
>License (GPL) version 2. Yes, Clara OCR is Free. Yes, Clara OCR
>is Open Source. Clara OCR is not "Shareware", nor "Public
>Domain".
>
>
>Is Clara OCR a GNU program?
>---------------------------
>
>Clara OCR is unrelated to the GNU Project but its development is
>strongly based on GNU programs (GCC, Emacs and others), as well
>as on other free softwares, like the Linux kernel and XFree86.
>
>Clara OCR is free software because we agree on the free software
>ideal as stated by the GPL. To make this agreement explicit we
>also adopted some suggestions from the Free Software
>Foundation. These suggestions apply to the Clara OCR
>documentation:
>
>(a) GPL programs are referred as "free software", not "open
>source".
>
>(b) The term "GNU/Linux (operating system)" is used rather
>than "Linux (operating system)".
>
>(c) We do not recommend non-free softwares and do not refer
>the user to non-free documentation for free softwares.
>
>Furthermore, Clara OCR will support Guile as an extension
>language in the near future.
>
>Remark: We write "free software" instead of "open source"
>just for coherence. We dislike antagonisms between the various
>initiatives created along the years to freely produce, use,
>change and distribute software.
>
>
>On which platforms does Clara OCR run?
>--------------------------------------
>
>Clara OCR is being developed on 32-bit Intel running GNU/Linux.
>Currently Clara OCR won't run on big-endian CPUs (e.g. Sparc) nor
>on systems lacking X windows support (e.g. MS-Windows). A
>relatively fast CPU (300MHz or more) is recommended. There is a
>port initiative to MS-Windows being worked. See also the next
>question.
>
>
>Does Clara OCR have a command-line interface?
>---------------------------------------------
>
>Yes, but the X Windows headers and libraries are required anyway
>to compile the source code, and the X Windows libraries are
>required to run even the Clara OCR command-line interface. Unless
>someone reworks the code, it's not possible to detach the GUI in
>order to compile Clara OCR on systems that do not support X
>Windows.
>
>
>
>Does Clara OCR run on KDE? GNOME?
>---------------------------------
>
>Clara OCR will hopefully run on any graphic environment based on
>Xwindows, including KDE, GNOME, CDE, WindowMaker and
>others. Clara OCR depends only on the X library, and does not
>require GTK, Qt or Motif to run. Clara OCR does not use the X
>Toolkit (aka "Xt"). Clara OCR has been successfully tested on
>X11R5 and X11R6 environments with twm, fvwm, mwm and others.
>
>
>Which languages are supported by Clara OCR?
>-------------------------------------------
>
>As a generic recogniser, Clara OCR may be tried with any language
>and any alphabet. However, there are some restrictions. Currently
>Clara OCR expects the words to be written horizontally, and there
>are some heuristics that suppose some geometric relationships
>typical for the Latin Alphabet and the accents used by most
>european languages. Support for language-specific spell checking
>is expected to be added soon.
>
>
>Does Clara OCR support Unicode?
>-------------------------------
>
>No, Clara OCR does not support Unicode, and the support to the
>ISO-8859 charsets is partial.
>
>
>Is Clara OCR omnifont?
>----------------------
>
>No, Clara OCR is not omnifont. Clara OCR implements an OCR model
>based on training. This model makes training and revision one
>same thing, making possible to reuse training and revision
>information (see also the next question).
>
>
>How does Clara differ from other OCRs?
>--------------------------------------
>
>This is a quote from the Clara Advanced User's Manual:
>
>Clara differs from other OCR softwares in various aspects:
>
>1. Most known OCRs are non-free and Clara is free. Clara focus
>the X windows system. Clara offers batch processing, a web
>interface and supports cooperative revision effort.
>
>2. Most OCR softwares focus omnifont technology disregarding
>training. Clara does not implement omnifont techniques and
>concentrate on building specialized fonts (some day in the
>future, however, maybe we'll try classification techniques that
>do not require training).
>
>3. Most OCR softwares make the revision of the recognized text a
>process totally separated from the recognition. Clara
>pragmatically joins the two processes, and makes training and
>revision parts of one same thing. In fact, the OCR model
>implemented by Clara is an interactive effort where the usage of
>the heuristics alternates with revision and fine-tuning of the
>OCR, guided by the user experience and feeling.
>
>4. Clara allows to enter the transliteration of each pattern
>using an interface that displays a graphic cursor directly over
>the image of the scanned page, and builds and maintains a mapping
>between graphic symbols and their transliterations on the OCR
>output. This is a potentially useful mechanism for documentation
>systems, and a valuable tool for typists and reviewers. In fact,
>Clara OCR may be seen as a productivity tool for typists.
>
>5. Most OCR softwares are integrated to scanning tools offerring
>to the user an unified interface to execute all steps from
>scanning to recognition. Clara does not offer one such integrated
>interface, so you need a separate software (e.g. SANE) to
>perform scanning.
>
>6. Most OCR softwares expect the input to be a graphic file
>encoded in tiff or other formats. Clara supports only raw PBM
>and PGM.
>
>
>What is PBM/PGM/PPM/PNM?
>------------------------
>
>PBM, PGM and PPM are graphic file formats defined by Jef
>Poskanzer. PNM is not a graphic file format, but a generic
>reference to those three formats. In other words, to say that a
>program supports PNM means that it handles PBM, PGM and PPM.
>
>    PBM = Portable BitMap
>    PGM = Protable GrayMap
>    PPM = Portable PixMap
>    PNM = Portable aNyMap
>
>PBM files are black-and-white images, 1 bit per pixel. PGM files
>are grayscale images, 8 bits per pixel. PPM files are color
>images, 24 bits per pixel. Currently Clara OCR likes raw PBM and
>raw PGM files only. A scanned page stored in some format other
>than PBM or PGM can be converted to PBM or PGM using the netpbm
>tools, ImageMagick or others.
>
>PNM files may be "raw" or "plain". The plain versions are rarely
>used. Clara OCR does not support plain PBM nor plain PGM. To make
>sure about the file format, try the "file" utility, for instance
>
>    file test.pbm
>
>Remember that image conversion sometimes implies data loss. For
>instance, to convert a color image to black-and-white, each pixel
>must be mapped to either black or white, so the original color
>(say, red, lightblue, seagreen, tomato, mistyrose, etc) is
>dropped. Also, the conversion process should decide for each
>pixel if it will be mapped to black or to white. Generally, the
>program that performs the conversion offers a variety of
>different mapping criteria. The OCR results depend strongly on
>the criterion chosen.
>
>
>How can I scan paper documents using Clara OCR?
>-----------------------------------------------
>
>You cannot. Clara OCR includes no support for scanners. To scan
>paper documents, use another software, like the one bundled with
>your scanner, or SANE (http://www.mostang.com/sane/). The
>development tests are using SANE.
>
>
>I've tried Clara OCR, but the results disappointed me
>-----------------------------------------------------
>
>All OCR programs will disappoint you depending on the texts
>you're trying to recognize. If you're a developer, join the Clara
>OCR development effort and try to make it behave better on your
>texts. If your are not a developer, wait a new version and try
>again.
>
>
>How can I get support on Clara OCR?
>-----------------------------------
>
>If the documentation did not solve your problems, try the
>discussion list.
>
>
>Does Clara OCR induce to Copyright Law infringements?
>-----------------------------------------------------
>
>No. Clara OCR is just a tool for character recognition like many
>others that can be purchased or are bundled with scanners. The
>Clara OCR Project claims all users to be aware about the
>Copyrigth Law and not infringe it. The Clara OCR Project
>abominates any try to infringe the legitimate laws of any
>country.
>
>Nonetheless, the Clara OCR Project supports the free and public
>availability of materials produced to be free, or of materials
>out of copyright due to its age. The Clara OCR Project recognizes
>the right of anyone to produce free or non-free materials.
>
>
>How can I help the Clara OCR development effort?
>------------------------------------------------
>
>The best way is to use Clara OCR to recognize the texts you're
>interested on, and try to make it adapt better to them. The
>Developer's Guide should help in this case (C programming skills
>are required). The Clara OCR Project acknowledges all efforts to
>make Clara OCR more widely known and used.
>
>
>*/
#line book.c:2962 (glossary)
>/* (glossary)
>
>WELCOME
>-------
>
>This is the Clara OCR glossary. It's somewhat specific to Clara
>OCR. The entries that do not refer an author were written by
>Ricardo Ueda Karpischek. Send new entries or suggestions to
>claraocr@claraocr.org. This glossary is part of the Clara OCR
>documentation. Clara OCR is distributed under the terms of the
>GNU GPL.
>
>
>CONTENTS
>--------
>
>algorithm
>binarization
>bitmap
>bitmap comparison
>border
>border mapping
>clara
>classification
>density
>depth
>digital image
>dpi
>function
>graphic format
>graymap
>heuristic
>image size
>mapping
>OCR
>page
>pattern
>pixel
>pixel distance
>pixmap
>PBM
>PGM
>PNM
>PPM
>resolution
>skeleton
>skeleton fitting
>symbol
>thresholding
>Xlib
>
>
>*/
#line book.c:3016 (glossary)
>/* (glossary)
>
>
>image size
>----------
>
>As a digital image uses to be a rectangular matrix of pixels, its
>size in pixels can be conveniently described giving the rectangle
>width and height, usually in the form WxH. For instance, a 200x100
>image is a rectangle of pixels having width 200 and height 100.
>
>depth
>-----
>
>the number of bits available to store the color of each pixel.
>Black-and-white images have depth 1. Graymaps use to have depth
>8 (256 graylevels). The larger the depth, the larger will be the
>amount of disk or ram space required to store a digital image.
>For instance, an image of size 100x100 and depth 8 requires
>100*100*8 = 80000 bits = 8000 bytes to be stored.
>
>graphic format
>--------------
>
>A standardised way to store the color of each pixel from a digital
>image in a disk file. The graphic format may include other
>information, like density and image annotations. Some graphic
>formats include a provision to compress the data. In some cases,
>this compression, if used, may change the color of some pixels
>or regions to colors close to the original ones, but different.
>So the usage of some graphic formats may imply in data loss.
>Examples of graphic formats are TIFF, JPEG, GIF, BMP, PNM, etc.
>
>clara
>-----
>
>Cooperative Lightweight Recognizer. "Clara" is also a personal
>name: Clara (Latin, Portuguese, Spanish), "Chiara" (Italian),
>Claire (English).
>
>
>OCR
>---
>
>Optical Character Recognition. Some people feel hard to
>understand conveniently what OCR is due to the lack of knowledge
>on how computers store and process text and image data. Most
>users think OCR as being a required step before editing and
>spell-checking documents got from the scanner (it's not wrong,
>though).
>
>algorithm
>---------
>
>a well defined procedure. The term "algorithm" is usually
>reserved for procedures whose properties can be assured,
>generally through a rigorous mathematical proof. For instance,
>the procedure learned by children to multiply two numbers from
>their multi-digit decimal representations is an algorithm (see
>heuristic).
>
>binarization
>------------
>
>the conversion from color or grayscale (PGM) to
>black-and-white. The Clara OCR classification heuristics
>currently available require black-and-white input, so when the
>input is grayscale (PGM), Clara OCR needs to convert it to
>black-and-white before OCR. Note that to binarize an image, some
>choice must be done on how to map colors or graylevels to either
>black or white. Also and mainly, and the OCR results depends
>strongly on that choice.
>
>bitmap
>------
>
>The Clara OCR documentation tries to use the term "bitmap" to
>mean only rectangular, black-and-white digital images. Grayscale
>rectangular digital images are called "graymaps" (see also
>pixel).
>
>bitmap comparison
>-----------------
>
>any method intended to decide if two given bitmaps are
>similar. Clara OCR implements three such methods: skeleton
>fitting, border mapping and pixel distance.
>
>border
>------
>
>the line formed by the bitmap black pixels that have white
>neighbours. Note that the definition of "neighbour" may
>vary. Clara OCR generally consider that the neighbours of one
>pixel are all 8 pixels contiguous to it (top left, top, top
>right, left, right, bottom left, bottom, bottom right).
>
>border mapping
>--------------
>
>a bitmap comparison technique that builds a mapping from the
>border pixels of one bitmap to the border pixels of another
>bitmap. If this mapping is found to satisfy certain mathematical
>properties, the bitmaps are considered similar.
>
>classification
>--------------
>
>the process that recognizes a given bitmap as being the letter
>"a" or the digit "5", etc. Instead of saying that the bitmap was
>"recognized" as a letter "a", it's common to say that it was
>"classified" as a letter "a". All Clara OCR classification
>methods are currently based on bitmap comparison techniques.
>
>density
>-------
>
>see dpi.
>
>digital image
>-------------
>
>see pixel.
>
>dpi
>---
>
>dots-per-inch. A measure of linear image density. Example:
>scanning an A4 (210x297mm) page at 300 dpi results an image of
>size 2481x3508 (remember that 1 inch equals 25.4 millimeters). In
>most cases, all relevant visual details from printed characters
>can be conveniently captured at 600dpi (in some cases, 300dpi
>suffices). Some file formats, like TIFF or JPEG, include density
>information. Others, like PBM, PGM or PPM, don't. So when
>converting from TIFF to PGM, remember that the density
>information is dropped. So if, for instance, you ask SANE to scan
>a page creating a TIFF file, and subsequently convert it to PPM,
>and from PPM to TIFF again, the last file will not be equal to
>the first one. Density information uses to be irrelevant when
>displaying images on the computer monitor, because in this case a
>1-1 mapping between image pixels and display pixels is
>assumed. However, density information is quite important when
>printing an image on paper, or when performing OCR. Clara OCR
>expects to be informed explicitly about the image density
>(default 600 dpi).
>
>function
>--------
>
>a rule that assigns, for each given element, another element, in
>a unique fashion. For instance, the equation y = x+1 defines a
>function that assigns to each number x the number x+1. A 2d
>digital image may be seen as a function that assigns to each dot,
>given by its horizontal and vertical coordinates, a color
>("black", "white", "green", etc). Functions are also called
>"mappings".
>
>graymap
>-------
>
>see bitmap.
>
>heuristic
>---------
>
>a procedure whose properties are not assured. Heuristics are
>generally the expression of some more or less vague feeling, or a
>naive, initial approch for a complex problem. If an heuristic can
>be proven to satisfy some interesting property, then it can be
>referred as an algorithm (in regard of that property). Some
>experts say that OCR is an engeneering field, not a mathematical
>field. Perhaps we can express this same idea saying that by its
>own nature, OCR is a field where nothing else than heuristics can
>be stated.
>
>mapping
>-------
>
>see function.
>
>page
>----
>
>a scanned document. The Clara OCR documentation tries to avoid
>using terms like "document", "image" or "file" to signify a
>scanned document. "Page" is used instead.
>
>pattern
>-------
>
>in the Clara OCR context, it's a letter, digit or accent
>instance, used to classify the page symbols through bitmap
>comparison. Clara OCR builds a set of patterns based on manual
>training or automatic selection, and uses it to classify all page
>symbols.
>
>pixel
>-----
>
>each one of the individual dots that compose a digital image
>(quite frequently, the term "pixel" is used to refer only the
>non-white dots of an image). A digital image uses to be a
>rectangular matrix of dots. To each one it's possible to assign
>one from many available colors, in order to form an image. If the
>available colors are only "black" and "white", the image thus
>formed is a "black-and-white image". As the representation of one
>from two possible values may be done using a bit, and the
>assignment of geometrically well positioned dots to colors may be
>seen as a function or mapping, a black-and-white image is also
>called a "bitmap". Similarly, if the colors available are only
>gray levels, usually from 0 (black) to 255 (white), then the
>image is a "grayscale image" or a graymap, and a generic
>assignment of pixels to colors is called a "pixmap".
>
>pixel distance
>--------------
>
>a bitmap comparison technique that builds a mapping from all
>pixels of one bitmap to the pixels of another bitmap. If this
>mapping is found to satisfy certain mathematical properties, the
>bitmaps are considered similar.
>
>pixmap
>------
>
>see pixel.
>
>PBM
>---
>
>see PNM.
>
>PGM
>---
>
>see PNM.
>
>PNM
>---
>
>Portable aNyMap. PNM is a generic reference to the graphic file
>formats PBM, PGM and PPM defined by Jef Poskanzer. In other
>words, to say that a program supports PNM means that it handles
>PBM, PGM and PPM. PBM (Portable BitMap) files are black-and-white
>images, 1 bit per pixel. PGM (Protable GrayMap) files are
>grayscale images, 8 bits per pixel. PPM (Portable PixMap) files
>are color images, 24 bits per pixel. Currently Clara OCR likes
>PBM and PGM files only. A scanned page stored in some format
>other than PBM or PGM can be converted to PBM or PGM using the
>netpbm tools, ImageMagick or others. PNM files may be "raw" or
>"plain". The plain versions are rarely used. Clara OCR does not
>support plain PBM nor plain PGM.
>
>PPM
>---
>
>see PNM.
>
>resolution
>----------
>
>this term is used along the Clara OCR documentation to refer
>either the image size (for instance: 640x480 pixels) or the image
>density (for instance: 300 pixels per inch).
>
>skeleton
>--------
>
>ideally, it's a minimal structural bitmap. From an algorithmic
>standpoint, the skeleton of a symbol is the bitmap obtained
>clearing a number of its peripheric pixels, whose remotion does
>not destroy the symbol shape.
>
>skeleton fitting
>----------------
>
>a bitmap comparison technique that decides that two given bitmaps
>are similar if and only if the skeleton of each one fits into the
>other.
>
>symbol
>------
>
>an instance of a letter or digit in a page. So if the word
>"classical" occurs in a page, all its letters ("c", "l", "a",
>"s", "s", "i", "c", "a", "l") are individual symbols. At the
>source code level, things that are not letters not digits are
>sometimes called symbols (for instance, pieces of broken symbols,
>dots, accents, noise, etc).
>
>thresholding
>------------
>
>a simple binarization method. It decides to map each pixel from a
>graymap to either black or white just testing if its gray level
>is smaller or larger than a given threshold. So, if the threshold
>is, say, 171, then all gray levels from 0 to 170 are mapped to 0
>(black) and all graylevels from 171 to 255 are mapped to 255
>(white). The thresholding is said to be global if one fixed
>(per-page) binarization threshold is used to decide the mapping
>of all page pixels. The thresholding is said to be local if the
>threshold is allowed to vary along the page, due to irregular
>printing intensity.
>
>Xlib
>----
>
>the low-level, standard, Xwindows library. It offers
>basic graphic primitives, similar to others found on most graphic
>environments, like "draw line", "draw pixel", "get next event",
>etc, as well as services more specific to the Xwindows way of
>doing things, like "connect to an X display", properties
>(resources) handling, etc. The Xlib does not include facilities
>to create menus, buttons, etc. Application programs usually take
>these facilities from "toolkits" like Xt, GTK, Qt and
>others. Clara OCR creates the few facilities it needs using
>the Xlib primitives.
>
>*/
#line clara.c:154 (book)
>/* (book)
>
>
>A first OCR project
>-------------------
>
>Clara OCR is intended to OCR a relatively large collection of pages at
>once, typically a book. So we will refer the material that we are
>OCRing as "the book".
>
>Let's describe a small but real project as an example on how to use
>Clara to OCR one "book". This section is in fact an in-depth tutorial
>on using Clara OCR. In order to try all techniques explained along
>this section, please download and uncompress the file referred as
>"page 143" of Manuel Bernardes Branco Dictionary (Lisbon, 1879),
>available at http://www.claraocr.org. It's a tarball containing the
>two text columns (one per file) of that page.
>
>Just to make the things easier, we will assume that the files
>143-l.pgm and 143-r.pgm were downloaded to the directory
>/home/clara/books/MBB/pgm/. We will assume also that the programs
>"clara", and "selthresh" are on the PATH. Some programs
>required to handle PBM files (pgmtopbm, pnmrotate and others, by
>Jef Poskanzer) are also required. These programs can be easily
>found around there, and are included on most free operating
>systems.
>
>
>The work directory
>------------------
>
>Clara OCR expects to find on one same directory one or more
>images of scanned pages. In our case, this directory is assumed
>to be /home/clara/books/BC/pbm. By default, on this same
>directory, various files will be created to store the OCR data
>structures. So, if 143-l.pbm and 143-r.pbm are the pages to OCR, then
>after processing all pages at least once (not done yet) the work
>directory will contain the following files:
>
>    143-l.pbm
>    143-l.html
>    143-l.session
>    143-r.pbm
>    143-r.html
>    143-r.session
>    acts
>    patterns
>
>The files "*.pbm" are the PBM images, the files "*.html" are the
>current OCR output, the file "patterns" is the current
>"bookfont", the file "143-l.session" contains the OCR data structures
>for the page 143-l.pbm, and the file "acts" stores the human revision
>effort already spent.
>
>When Clara OCR is processing the page x.pbm, the files
>"x.session", "acts" and "patterns" are in memory. These three
>files together are generally referred as "the section". So the
>menu option "save session" means saving all three files.
>
>
>Using two directories
>---------------------
>
>In order to make easier the usage of read-only media, Clara OCR
>allows splitting the files in two directories, one for images and
>other for work files. The path of the first is stored on
>pagesdir, and the second, on workdir. For instance:
>
>  (pagesdir)
>
>    |
>    +- 1.pbm
>    |
>    +- 2.pbm
>
>
>  (workdir)
>
>    |
>    +- 1.session
>    |
>    +- 1.html
>    |
>    +- 2.session
>    |
>    +- 2.html
>    |
>    +- acts
>    |
>    +- font
>
>
>In this example, there are 2 pages (files "1.pbm" and
>"2.pbm"). The current font is the file "pattern". The files
>1.session and 2.session are the dumps of the data structures
>built when processing the pages 1 and 2. The files 1.html and
>2.html contain the current OCR output generated for pages 1 and 2.
>
>
>Multiple books
>--------------
>
>A somewhat rigid directory structure is recommended for
>high-volume digitalization projects based on Clara and using the
>web interface. In this case, there will be multiple "pagesdir"
>directories ("book1" and "book2" from the docsroot in the figure)
>and, for each one, a corresponding "workdir" ("book1" and "book2"
>from the workroot in the figure).
>
>  (booksroot)
>
>    |
>    +- book1/
>    |       +- 1.pbm
>    |       |
>    |       +- 2.pbm
>    |
>    |
>    +- book2/
>            +- 1.pbm
>            |
>            +- 2.pbm
>
>
>  (workroot)
>
>    |
>    +- book1/
>    |       +- 1.session
>    |       |
>    |       +- 1.html
>    |       |
>    |       +- 2.session
>    |       |
>    |       +- 2.html
>    |       |
>    |       +- acts
>    |       |
>    |       +- doubts/
>    |       |        +- s.1.319.pbm
>    |       |        |
>    |       |        +- u.2.7015.pbm
>    |       |        |
>    |       |        +- 1.958225189.17423.hal
>    |       |
>    |       +- pattern
>    |
>    +- book2/
>    |       +- 1.session
>    |       |
>
>
>For each book subdirectory on the workroot subtree, there will be
>a "doubts" directory, used to communicate with the web
>server. Each OCR run on some page of this book will generate
>files of the form "u.page.symbol.pbm", that contains a pbm image
>of one symbol. Once the CGI is
>claimed to produce a revision page, it will choose one of these
>files and rename it to s.page.symbol.pbm. This procedure is
>performed without using locks, so two simultaneous revision
>acesses may access the same symbol. The revision submission
>generates a qmail-style file doc.time.pid.host.
>
>*/
#line clara.c:319 (devel)
>/* (devel)
>
>Path variables
>--------------
>
>Most path variables are computed from the path given through
>the -f command line option. The variable "pagename" is the filename
>of the PBM image of the page being processed, not
>including the path eventually specified through the -f
>switch. For instance, if the OCR is started with
>
>    clara -f mydocs/test.pbm
>
>Then the value of the variable "pagename" will be just
>"test.pbm". The variable pagebase is pagename without the
>suffix ".pbm" ("test", in the example).
>
>Clara stores on the variable pagelist the null-separated list of
>all names of pbm files found on this directory. Even in this
>case, the variable pagename will store the filename of the page
>being processed (at any moment Clara will be processing one and
>only one page).
>
>The directory that contains the pbm files that Clara will
>process is stored on the variable pagesdir. In the example
>above, the value of the variable pagesdir is "mydocs/".
>
>The variable workdir stores the path of the directory where Clara
>will create the files *.html, *.session, "patterns" and
>"acts". This path is assumed to be equal to pagesdir, unless
>another path is given through the -w switch. The variable
>doubtsdir will be the concatenation of workdir with the string
>"doubts/" (doubtsdir is ignored if -W is not used).
>
>*/
#line clara.c:424 (devel)
>/* (devel)
>
>OCR statuses
>------------
>
>The OCR run in course (if any) stores various statuses on global
>variables. For instance, the ocring macro will be nonzero if one
>OCR run is in course. The GUI informs the OCR control routines
>about what to do along the OCR run using various global
>variables. Some of them drive the classification procedures:
>
>  justone      .. Classify only one symbol
>  this_pattern .. Use only one pattern to classify
>  recomp_cl    .. Ignore current classes
>
>The first two are used for testing purposes, for instance when
>checking why the classification routines classified some symbol
>unexpected way.
>
>The stop_ocr variable is set by the GUI when the STOP button is
>pressed. Its status will be tested by the routines that control
>the OCR run in course. Note that the variable cannot_stop may be
>set by the current OCR step in course. It's effect is to inhibit
>the GUI setting the stop_ocr status. It's used by routines that
>cannot be stopped, otherwise the data structures they're handling
>would rest in a irrecuperable inconsistency.
>
>The OCR control routines handle the following statuses:
>
>  ocr_all  .. OCR all pages
>  starting .. continue_ocr was not called until now
>  onlystep .. run only this OCR step
>
>The buttons CLASSIFY, BUILD, etc, start one specific OCR
>step. The OCR step to be executed is stored on onlystep. The
>to_ocr variable stores the page where the OCR run will be
>executed.
>
>The other to_* variables together with nopropag store information
>about the revision operation requested from the GUI:
>
>  to_tr    .. the transliteration to submit to the current symbol
>  to_rev   .. the type of revision
>  nopropag .. propagation flag for the result
>  to_arg   .. integer argument to revision operation
>
>The types of revision are: transliteration submission (1),
>fragment merging (2), symbol disassemble (3) and word extension
>(4).
>
>The to_arg variable stores the flagment to merge to the current
>symbol or the symbol to add to the current word.
>
>The variable ocr_other stores which operation to perform by the
>OCR_OTHER step. This step is reserved to operations that are outside
>the OCR run main stream, but require the control provided by the
>continue_ocr function.
>
>The variable text_switch redirects (if nonzero) the DEBUG window
>output to an internal array.
>
>*/
#line clara.c:543 (book)
>/* (book)
>
>Page geometry parameters
>------------------------
>
>For best results, when OCRing an entire book, it's convenient to
>spend some time gathering geometric parameters common to all
>pages. These parameters will be useful to drive the OCR
>heuristics. Currently there are 9 such parameters: LW, LH, DD,
>LS, TC, SL, LM, RM, TM and BM, all floats except TC and SL. Not
>all them are currently used by the engine. Each one can be
>informed using the var=value syntax. For example:
>
>    TC=2 SL=1
>
>For documentation purposes we divide these 9 parameters into 4
>groups:
>
>1. Symbol typical dimensions.
>
>LW .. letter width measured in millimeters.
>LH .. letter height measured in millimeters.
>DD .. dot diameter measured in millimeters.
>
>2. Vertical separation between lines.
>
>LS .. vertical line separation measured in millimeters.
>
>3. Number of text columns.
>
>TC .. number of text columns. Use "1" for just one text column,
>"2" or "3" for two or three text columns.
>
>SL .. separation line. Use "1" if there exists a vertical line
>separating text columns, "0" otherwise.
>
>4. Page margins.
>
>LM .. left margin measured in millimeters.
>RM .. right margin measured in millimeters.
>TM .. top margin measured in millimeters.
>BM .. bottom margin measured in millimeters.
>
>Useful remarks:
>
>a) 1 inch = 25.4 milimetres
>
>b) scanning resolution is a linear measure. So when scanning at
>600 dpi, there will be 600/25.4=23.6 lines per millimeter. So, for
>instance, 3 millimeters will correspond to 3*23.6=71 pixels.
>
>*/
#line clara.c:807 (devel)
>/* (devel)
>
>The memory allocator
>--------------------
>
>Clara OCR relies on the memory allocator both for allocation or
>resizing of some large blocks used by the main data structures, and
>for allocation of a large number of small arrays. Currently Clara OCR
>does not include or use an special memory allocator, but implements an
>interface to realloc. The alloca function is also used sometimes along
>the code, generally to allocate buffers for sorting arrays.
>
>The interface is the function c_realloc. The function c_free must be
>used to free the blocks allocated or resized by c_realloc. In the near
>future, c_realloc will build a list of the currently allocated blocks,
>their sizes and some bits more in order to help to trace flaws.
>
>*/
#line clara.c:2346 (book)
>        /* (book)
>
>            Reference of command-line switches
>            ----------------------------------
>
>            A number of internal variables now can be defined on
>            the command-line. Variable names can be optionally preceded
>            by '-'. If a value is absent, the default is 1. Examples:
>
>                clara -pp_deskew
>                clara pp_deskew
>                clara pp_deskew=1
>                clara -pp_deskew=1
>
>                (apply deskewer)
>
>                clara bin_method=3
>
>                (use the classification-based, local thresholder)
>
>            To known about the variables that can be defined on the
>            command line, see the source code, file clara.c,
>            function checkvar().
>
>        */
#line clara.c:2372 (book)
>        /* (book)
>
>            -a bf_auto,st_auto,st_auto_global,classifier
>
>            Bookfont handling options
>
>        */
#line clara.c:2383 (book)
>        /* (book)
>
>            -b
>
>            Run in batch mode.
>
>            The application window will not be created, and the OCR
>            will automatically execute a full OCR run on all pages
>            (or on the page specified through -f).
>
>            Implies -u.
>        */
#line clara.c:2400 (book)
>        /* (book)
>
>            -d
>
>            Run in debug mode. Debug messages will be sent to stderr.
>            Debug messages are generated when an acceptable but
>            not reasonable event is detected.
>        */
#line clara.c:2413 (book)
>        /* (book)
>
>            -e reviewer,type
>
>            Reviewer and reviewer type.
>
>            All revision data is assigned by Clara to its originator.
>            By default the reviewer name is "nobody" and its type
>            is "A".
>
>            The reviewer generally will be an email address or a
>            nickname, The type may be T (trusted), A (arbiter) or
>            N (anonymous). Example:
>
>                -e ueda@ime.usp.br,T
>
>        */
#line clara.c:2447 (book)
>        /* (book)
>
>            -f path
>
>            Scanned page or page directory. Defaults
>            to the current directory.
>
>            The argument must be a pbm file (with absolute or relative
>            path) or the path (absolute or relative) of the directory
>            where the pbm file(s) was (were) placed.
>
>            To specify a range of pages, use the restrictors start_at
>            and stop_at. Example:
>
>                $ clara start_at=12 stop_at=122
>
>            In this case pages like 12.pbm or 0033.pbm will be processed,
>            but pages like 9.pbm, 0009.pbm or 590.pbm won't.
>        */
#line clara.c:2474 (book)
>        /* (book)
>
>            -h
>
>            Display short help and exit.
>        */
#line clara.c:2486 (book)
>        /* (book)
>
>            -i
>
>            Emulate dead keys functionality.
>        */
#line clara.c:2496 (book)
>        /* (book)
>
>            -k list
>
>            Parameters SA,RR,MA,MP,ML,MB,RX,BT used to compute
>            skeletons.
>
>            BUG: these parameters are ignored when a "patterns"
>            already exists. In this case, Clara will read the
>            parameters from the "patterns" file.
>        */
#line clara.c:2517 (book)
>        /* (book)
>
>            -N list
>
>            Switch off optimizations. Generally useful only for debug
>            purposes. Non-supported displays depths (if any) may require
>            '-N d'. The argument is the list of the (one or more)
>            optimizations to switch off (s, a, j, q, c, x or d).
>            Examples:
>
>                -N s
>                -N aq
>                -N jq
>        */
#line clara.c:2555 (book)
>        /* (book)
>
>            -o t|h
>
>            Select output format (t=text, h=html, d=djvu). The
>            default is HTML.
>        */
#line clara.c:2574 (book)
>        /* (book)
>
>            -P PNT1,PNT2,MD
>
>            Parameters for filtering symbol comparison.
>
>            PNT1 and PNT2 are the pixel number thresholds. These
>            thresholds are used to filter out bad candidates
>            when classifying symbols. The first threshold
>            is for strong similarity and the second for weak
>            similarity. The comparison algorithm performs two
>            passes. The first pass uses PNT1 to filter. The
>            second pass uses PNT2. So on the first pass only
>            patterns "quite similar" to the symbol to
>            classify are tried. On the second pass, we relax
>            and permit more patterns to be tried. This method
>            helps to achieve a good performance. As PNT1 becomes
>            larger, less patterns will be tried on the first
>            pass. As PNT2 becomes smaller, more patterns will be
>            tried on the second pass.
>
>            MD is the maximum clearance to try a skeleton. The
>            clearance must be an integer in the range 4..30
>            (default 6). The shape recognition algorithm will
>            refuse to try to fit an skeleton into a symbol if
>            the difference of the widths or heights of them is
>            larger than twice the clearance.
>
>            Examples:
>
>                -P 50,5,8
>                -P 40,3,6
>
>        */
#line clara.c:2612 (book)
>        /* (book)
>
>            -R doubts
>
>            Maximum number of doubts per run. The argument must be
>            an integer (default 30).
>        */
#line clara.c:2640 (book)
>        /* (book)
>
>            -T
>
>            Avoid loading and creation of session files. Also reports bookfont size on
>            stdout before exiting. This option is intended to be used by the selthresh
>            script.
>        */
#line clara.c:2652 (book)
>        /* (book)
>
>            -t
>
>            Switch on trace messages. Trace messages depict
>            the execution flow, and are useful for developers.
>            Trace messages are written to stderr.
>        */
#line clara.c:2680 (book)
>        /* (book)
>
>            -v
>
>            Verbose mode. Without this option, Clara runs quietly
>            (default). Otherwise, informative warnings about
>            potentially relevant events are sent to stderr.
>        */
#line clara.c:2692 (book)
>        /* (book)
>
>            -V
>
>            Print version and compilation options and exit.
>        */
#line clara.c:2718 (book)
>        /* (book)
>
>            -W
>
>            Web mode. Will read from the doubts subdir the input
>            collected from web, and will dump on that same directory
>            the doubts to be reviewed.
>        */
#line clara.c:2730 (book)
>        /* (book)
>
>            -w path
>
>            Work directory. Defaults to the page
>            directory (see -f).
>
>            The path of the directory where the OCR will write
>            the output, the acts, the book font and the session
>            files. The doubts directory (web operation) is assumed
>            to be a subdirectory of the work directory.
>        */
#line clara.c:2759 (book)
>        /* (book)
>
>            -X 0|1
>
>            Switch off (0) or on (1) index checking. Index checking is
>            performed in some critical points in order to detect memory
>            leaks. Index checking is unavailable when Clara is compiled
>            with the symbol MEMCHECK undefined.
>        */
#line clara.c:2783 (book)
>        /* (book)
>
>            -y resolution
>
>            Inform the resolution of the scanned image in dots per inch
>            (default 600). This resolution applies for all pages to be
>            processed until the program exits.
>        */
#line clara.c:2796 (book)
>        /* (book)
>
>            -z
>
>            Write (and read) compressed session files (*.session, acts
>            and patters will be compressed using GNU zip).
>
>            Be careful: if -z is used, any existing uncompressed file
>            (*.session, acts or patterns) will be ignored. So if you
>            start using uncompressed files and suddenly decides to
>            begin using compressed files, then compress manually all
>            existing files before starting Clara with the -z switch.
>
>            Clara OCR support for reading and writing compressed files
>            depends on the platform, and requires gzip and gunzip to
>            be installed in some directory of binaries included in
>            the PATH.
>        */
#line clara.c:2818 (book)
>        /* (book)
>
>            -Z ZPS
>
>            ZPS, that is, the size of the bitmap pixels measured in
>            display pixels, when in fat bit mode. Must be a small odd
>            integer (1, 3, 5, 7 or 9).
>        */
#line clara.c:4357 (devel)
>/* (devel)
>
>The function start_ocr
>----------------------
>
>Starts a complete OCR run or some individual OCR step on one
>given page, or on all pages. For instance, start_ocr is called by
>the GUI when the user presses the "OCR" button or when the user
>requests loading of one specific page.
>
>In fact, almost all user requested operation is performed as an
>"ocr step"in order to take advantage from the execution model
>implemented by the function continue_ocr. So start_ocr is the
>starting point for attending almost all user requests.
>
>If p is -1, process all pages, if p < -1, process only the current
>page (cpage) otherwise process only the page p. If s>=0 then run only
>step s, otherwise run all steps.
>
>If the flag r is nonzero, will ignore the current classes (if
>any) and recompute them again (this is meaningful only to the
>symbol classification step).
>
>*/
#line skel.c:85 (devel)
>/* (devel)
>
>Skeleton pixels
>---------------
>
>The first method implemented by Clara OCR for symbol classification
>was skeleton fitting. Two symbols are considered similar when each
>one contains the skeleton of the other.
>
>Clara OCR implements five heuristics to compute skeletons. The
>heuristic to be used is informed through the command-line option
>-k as the SA parameter. The value of SA may be 0, 1, 2, 3 or 4.
>
>Heuristics 0, 1 and 2 consider a pixel as being a skeleton pixel
>if it is the center of a circle inscribed within the closure, and
>tangent to the pattern boundary in more than one point.
>
>The discrete implementation of this idea is as follows: for each
>pixel p of the closure, compute the minimum distance d from p to
>some boundary pixel. Now try to find two pixels on the closure
>boundary such that the distance from each of them to p does not
>differ too much from d (must be less than or equal to RR). These
>pixels are called "BPs".
>
>To make the algorithm faster, the maximum distance from p to the
>boundary pixels considered is RX. In fact, if there exists a
>square of size 2*BT+1 centered at p, then p is considered a
>skeleton pixel.
>
>As this criteria alone produces fat skeletons and isolated
>skeleton pixels along the closure boundary, two other conditions
>are imposed: the angular distance between the radiuses from p to
>each of those two pixels must be "sufficiently large" (larger
>than MA), and a small path joining these two boundary pixels
>(built only with boundary pixels) must not exist (the "joined"
>function computes heuristically the smallest boundary path
>between the two pixels, and that distance is then compared to
>MP).
>
>The heuristics 1 and 2 are variants of heuristic 0:
>
>1. (SA = 1) The minimum linear distance between the two BPs
>is specified as a factor (ML) of the square of the radius. This
>will avoid the conversion from rectangular to polar coordinates
>and may save some CPU time, but the results will be slightly
>different.
>
>2. (SA = 2) No minimum distance checks are performed, but a
>minimum of MB BPs is required to exist in order to consider the
>pixel p a skeleton pixel.
>
>The heuristic 3 is very simple. It computes the skeleton removing
>BT times the boundary.
>
>The heuristic 4 uses "growing lines". For angles varying in steps
>of approximately 22 degrees, a line of lenght RX pixels is drawn
>from each pixel. The heuristic check if the line can or cannot be
>entirely drawn using black pixels. Depending on the results, it
>decides if the pixel is an skeleton pixel or not. For instance:
>if all lines could be drawn, then the pixel is center of an
>inscribed circle, so it's considered an skeleton pixels. All
>considered cases can be found on the source code.
>
>The heuristic 5 computes the distance from each pixel to the
>border, for some definition of distance. When the distance is
>at least RX, it is considered a skeleton pixel. Otherwise,
>it will be considered a skeleton pixel if its distance to the
>border is close to the maximum distance around it (see the code
>for details).
>
>All parameters for skeleton computation are informed to Clara
>through the -k command-line option, as a list in the following
>order: SA,RR,MA,MP,ML,MB,RX,BT. For instance:
>
>    clara -k 2,1.4,1.57,10,3.8,10,4,4
>
>The default values and the valid ranges for each parameter must
>be checked on the source code (see the declaration of the
>variables SA, RR, MA, MP, ML, MB, RX, and BT, and the function
>skel_parms). Note that BT must be at most RX.
>
>*/
#line event.c:97 (devel)
>/* (devel)
>
>Redraw flags
>------------
>
>The redraw flags inform the function redraw about which portions
>of the application window must be redraw. The precise meaning of
>each flag depends on the implementation of the redraw function,
>that can be analysed directly on the source code.
>
>    redraw_button .. one specific button or all buttons
>    redraw_bg     .. redraw background
>    redraw_grid   .. the grid on fatbits windows
>    redraw_stline .. the status line
>    redraw_dw     .. all visible windows
>    redraw_inp    .. all text input fields
>    redraw_tab    .. tabs and their labels
>    redraw_zone   .. rectangle that defines the zone
>    redraw_menu   .. menu bar and currently open menu
>    redraw_j1     .. redraw junction 1 (page tab)
>    redraw_j2     .. redraw junction 2 (page tab)
>    redraw_pbar   .. progress bar
>    redraw_map    .. alphabet map
>    redraw_flea   .. the flea
>
>An individual button may be redraw to reflect a status change
>(on/off). The junction 1 is the junction of the top and middle
>windows on the page tab, and the junction 2 is the junction of
>the middle and bottom window on the page tab. The correspondig
>flags are used when resizing some window on the page tab.
>
>If redraw_menu is 2, the menu is entirely redrawn. If redraw_menu is
>1, then the draw_menu function will redraw only the last selected item
>and the newly selected item, except if the menu is being drawn by the
>first time.
>
>The progress bar is displayed on the bottom of the window to
>reflect the progress of some slow operation. By now, the
>progress bar is unused.
>
>*/
#line event.c:230 (devel)
>/* (devel)
>
>The zones
>---------
>
>Clara OCR allows to create "zones". Zones are usually used to identify
>one text block in the page. For instance, a page containing two text
>columns should use one zone to limit each column. The zone limits are
>given by the "limits" array. The top left is (limits[0],limits[1]) as
>presented by the figure:
>
>    +---------------------------+
>    | (0,1)       (6,7)         |
>    |  +-----------+            |
>    |  |this is a  |            |
>    |  |text block |            |
>    |  |identifyed |            |
>    |  |by a       |            |
>    |  |rectangular|            |
>    |  |zone.      |            |
>    |  +-----------+            |
>    | (2,3)       (4,5)         |
>    |                           |
>    +---------------------------+
>
>Multiple zones are supported simultaneously, and each one is handled
>separately when building words and lines and generating the
>output. The limits of the second zone are limists[8..15], and so
>on. Also, non-rectangular zones are supported, in order to cover
>nonrectangular (skewed) text blocks.
>
>*/
#line event.c:403 (devel)
>/* (devel)
>
>The function show_hint
>----------------------
>
>Messages are put on the status line (on the bottom of the
>application X window) using the show_hint service. The show_hint
>service receives two parameters: an integer f and a string (the
>message).
>
>If f is 0, then the message is "discardable". It won't be
>displayed if a permanent message is currently being displayed.
>
>If f is 1, then the message is "fixed". It won't be erased by a
>subsequent show_hint call informing as message the empty string
>(in practical terms, the pointer motion won't clear the message).
>
>If f is 2, then the message is "permanent" (the message will be
>cleared only by other fixed or permanent message).
>
>If f is 3, clear any current message.
>
>*/
#line event.c:4149 (book)
>            /* (book)
>
>                The Application Buttons
>                -----------------------
>
>                The application buttons are those displayed on the
>                left portion of the Clara X window. They're
>                labelled "zoom", "OCR", etc. Three types of
>                buttons are available. There are on/off buttons
>                (like "italic"), multi-state buttons (like the
>                alphabet button), where the state is informed by
>                the current label, and there are buttons that
>                merely capture mouse clicks, like the "zoom"
>                button. Some are sensible both to mouse button 1
>                and to mouse button 3, others are sensible only to
>                mouse button 1.
>
>            */
#line event.c:4168 (book)
>            /* (book)
>
>                zoom - enlarge or reduce bitmaps. The mouse buttom 1
>                enlarge bitmaps, the mouse button 3 reduce bitmaps.
>                The bitmaps to enlarge or reduce are determined
>                by the current window. If the PAGE window is active,
>                then the scanned document is enlarged or reduced.
>                If the PAGE (fatbits) or the PATTERN window is active,
>                then the grid is enlarged or reduced. If the PAGE
>                (symbol) or the PATTERN (props) or the PATTERN (list)
>                window is active, then the web clip is enlarged or
>                reduced.
>
>            */
#line event.c:4255 (book)
>            /* (book)
>
>                OCR - start a full OCR run on the current page or on
>                all pages, depending on the state of the "Work on
>                current page only" item of the Options menu.
>
>            */
#line event.c:4280 (book)
>            /* (book)
>
>                stop - stop the current OCR run (if any). OCR
>                does not stop immediately, but will stop
>                as soon as possible.
>
>            */
#line event.c:4302 (book)
>            /* (book)
>
>                zone - start definition of the OCR zone. Currently
>                zoning in Clara OCR is useful only for saving the
>                zone can as a PBM file, using the "save zone" item
>                on the "File" menu. By now, only one zone can be
>                defined and the OCR operations consider the
>                entire document, ignoring the zone.
>
>            */
#line event.c:4336 (book)
>            /* (book)
>
>                type - read-only button, set accordingly to the pattern
>                type of the current symbol or pattern. The various letter
>                sizes or styles (normal, footnote, etc) used by the book are
>                numbered from 0 by Clara OCR ("type 0", "type 1", etc).
>
>            */
#line event.c:4372 (book)
>            /* (book)
>
>                bad - toggles the button state. The bad flag
>                is used to identify damaged bitmaps.
>
>            */
#line event.c:4411 (book)
>            /* (book)
>
>                latin/greek/etc - read-only button, set accordingly to
>                the alphabet of the current symbol or pattern.
>
>            */
#line event.c:5462 (book)
>    /* (book)
>
>        File menu
>        ---------
>
>        This menu is activated from the menu bar on the top of the
>        application X window.
>    */
#line event.c:5526 (book)
>    /* (book)
>
>        Save session
>
>        Save on disk the page session (file page.session), the patterns
>        (file "pattern") and the revision acts (file "acts").
>    */
#line event.c:5535 (book)
>    /* (book)
>
>        Save first zone
>
>        Save on disk the first zone as the file zone.pbm.
>    */
#line event.c:5543 (book)
>    /* (book)
>
>        Save replacing symbols
>
>        Save on disk the entire page replacing symbols by patterns,
>        to achieve better compression rates (mostly to produce small
>        web images).
>    */
#line event.c:5553 (book)
>    /* (book)
>
>        Write report
>
>        Save the contents of the PAGE LIST window to the file
>        report.txt on the working directory.
>    */
#line event.c:5562 (book)
>    /* (book)
>
>        Quit the program
>
>        Just quit the program (asking before if the session is to
>        be saved.
>    */
#line event.c:5572 (book)
>    /* (book)
>
>        Edit menu
>        ---------
>
>        This menu is activated from the menu bar on the top of the
>        application X window.
>    */
#line event.c:5582 (book)
>    /* (book)
>
>        Only doubts
>
>        When selected, the right or the left arrows used on the
>        PATTERN or the PATTERN PROPS windows will move to the next
>        or the previous untransliterated patterns.
>    */
#line event.c:5592 (book)
>    /* (book)
>
>        Re-scan all patterns
>
>        When selected, the classification heuristic will retry
>        all patterns for each symbol. This is required when trying
>        to resolve the unclassified symbols using a second
>        classification method.
>    */
#line event.c:5603 (book)
>    /* (book)
>
>        Auto-classify.
>
>        When selected, the engine will re-run the classifier after
>        each new pattern trained by the user. So if various letters
>        "a" remain unclassified, training one of them will perhaps
>        recognize some othersm helping to complete the recognition.
>    */
#line event.c:5615 (book)
>    /* (book)
>
>        Fill region
>
>        When selected, the mouse button 1 will fill the region
>        around one pixel on the pattern bitmap under edition on the
>        font tab.
>    */
#line event.c:5625 (book)
>    /* (book)
>
>        Paint pixel
>
>        When selected, the mouse button 1 will paint individual
>        pixels on the pattern bitmap under edition on the font tab.
>    */
#line event.c:5634 (book)
>    /* (book)
>
>        Clear region
>
>        When selected, the mouse button 1 will clear the region
>        around one pixel on the pattern bitmap under edition on the
>        font tab.
>    */
#line event.c:5644 (book)
>    /* (book)
>
>        Clear pixel
>
>        When selected, the mouse button 1 will clear individual
>        pixels on the pattern bitmap under edition on the font tab.
>    */
#line event.c:5653 (book)
>    /* (book)
>
>        Sort patterns by page
>
>        When selected, the pattern list window will divide
>        the patterns in blocks accordingly to their (page)
>        sources.
>    */
#line event.c:5664 (book)
>    /* (book)
>
>        Sort patterns by matches
>
>        When selected, the pattern list window will use as the
>        first criterion when sorting the patterns, the number of
>        matches of each pattern.
>    */
#line event.c:5674 (book)
>    /* (book)
>
>        Sort patterns by transliteration
>
>        When selected, the pattern list window will use as the
>        second criterion when sorting the patterns, their
>        transliterations.
>    */
#line event.c:5684 (book)
>    /* (book)
>
>        Sort patterns by number of pixels
>
>        When selected, the pattern list window will use as the
>        third criterion when sorting the patterns, their
>        number of pixels.
>    */
#line event.c:5694 (book)
>    /* (book)
>
>        Sort patterns by width
>
>        When selected, the pattern list window will use as the
>        fourth criterion when sorting the patterns, their
>        widths.
>    */
#line event.c:5704 (book)
>    /* (book)
>
>        Sort patterns by height
>
>        When selected, the pattern list window will use as the
>        fifth criterion when sorting the patterns, their
>        heights.
>    */
#line event.c:5714 (book)
>    /* (book)
>
>        Del Untransliterated patterns
>
>        Remove from the font all untransliterated fonts.
>    */
#line event.c:5723 (book)
>    /* (book)
>
>        Set pattern type.
>
>        Set the pattern type for all patterns marked as "other".
>    */
#line event.c:5731 (book)
>    /* (book)
>
>        Search barcode.
>
>        Try to find a barcode on the loaded page.
>    */
#line event.c:5739 (book)
>    /* (book)
>
>        Instant thresholding.
>
>        Perform on-the-fly global thresholding.
>    */
#line event.c:5748 (book)
>    /* (book)
>
>        Reset skeleton parameters
>
>        Reset the parameters for skeleton computation for all
>        patterns.
>    */
#line event.c:5758 (book)
>    /* (book)
>
>        View menu
>        ---------
>
>        This menu is activated from the menu bar on the top of the
>        application X window.
>    */
#line event.c:5769 (book)
>    /* (book)
>
>        Small font
>
>        Use a small X font (6x13).
>    */
#line event.c:5777 (book)
>    /* (book)
>
>        Medium font
>
>        Use the medium font (9x15).
>    */
#line event.c:5785 (book)
>    /* (book)
>
>        Small font
>
>        Use a large X font (10x20).
>    */
#line event.c:5793 (book)
>    /* (book)
>
>        Default font
>
>        Use the default font (7x13 or "fixed" or the one informed
>        on the command line).
>    */
#line event.c:5802 (book)
>    /* (book)
>
>        Hide scrollbars
>
>        Toggle the hide scrollbars flag. When active, this
>        flag hides the display of scrolllbar on all windows.
>    */
#line event.c:5813 (book)
>    /* (book)
>
>        Omit fragments
>
>        Toggle the hide fragments flag. When active,
>        fragments won't be included on the list of
>        patterns.
>    */
#line event.c:5824 (book)
>    /* (book)
>
>        Show HTML source
>
>        Show the HTML source of the document, instead of the
>        graphic rendering.
>    */
#line event.c:5834 (book)
>    /* (book)
>
>        Show web clip
>
>        Toggle the web clip feature. When enabled, the PAGE_SYMBOL
>        window will include the clip of the document around the
>        current symbol that will be used through web revision.
>    */
#line event.c:5844 (book)
>    /* (book)
>
>        Show alphabet map
>
>        Toggle the alphabet map display. When enabled, a mapping
>        from Latin letters to the current alphabet will be
>        displayed.
>    */
#line event.c:5855 (book)
>    /* (book)
>
>        Show current class
>
>        Identify the symbols on the current class using
>        a gray ellipse.
>    */
#line event.c:5865 (book)
>    /* (book)
>
>        Show matches
>
>        Display bitmap matches when performing OCR.
>    */
#line event.c:5873 (book)
>    /* (book)
>
>        Show comparisons
>
>        Display all bitmap comparisons when performing OCR.
>    */
#line event.c:5881 (book)
>    /* (book)
>
>        Show matches
>
>        Display bitmap matches when performing OCR,
>        waiting a key after each display.
>    */
#line event.c:5890 (book)
>    /* (book)
>
>        Show comparisons and wait
>
>        Display all bitmap comparisons when performing OCR,
>        waiting a key after each display.
>    */
#line event.c:5899 (book)
>    /* (book)
>
>        Show skeleton tuning
>
>        Display each candidate when tuning the skeletons of the
>        patterns.
>    */
#line event.c:5908 (book)
>    /* (book)
>
>        OCR steps menu
>        --------------
>
>        This menu is activated when the mouse button 3 is pressed on
>        the OCR button. It allows running specific OCR steps (all
>        steps run in sequence when the OCR button is pressed).
>
>    */
#line event.c:5923 (book)
>    /* (book)
>
>        Preproc.
>
>        Start preproc.
>    */
#line event.c:5931 (book)
>    /* (book)
>
>        Detect blocks
>
>        Start detecting text blocks.
>
>    */
#line event.c:5940 (book)
>    /* (book)
>
>        Segmentation.
>
>        Start binarization and segmentation.
>    */
#line event.c:5948 (book)
>    /* (book)
>
>        Consist structures
>
>        All OCR data structures are submitted to consistency
>        tests. This is under implementation.
>    */
#line event.c:5957 (book)
>    /* (book)
>
>        Prepare patterns
>
>        Compute the skeletons and analyse the patterns for
>        the achievement of best results by the classifier. Not
>        fully implemented yet.
>    */
#line event.c:5967 (book)
>    /* (book)
>
>        Read revision data
>
>        Revision data from the web interface is read, and
>        added to the current OCR training knowledge.
>    */
#line event.c:5976 (book)
>    /* (book)
>
>        Classification
>
>        start classifying the symbols of the current
>        page or of all pages, depending on the state of the
>        "Work on current page only" item of the Options menu. It
>        will also build the font automatically if the
>        corresponding item is selected on the Options menu.
>
>    */
#line event.c:5989 (book)
>    /* (book)
>
>        Geometric merging
>
>        Merge closures on symbols depending on their
>        geometry.
>    */
#line event.c:5998 (book)
>    /* (book)
>
>        Build words and lines
>
>        Start building the words and lines. These heuristics will
>        be applied on the
>        current page or on all pages, depending on the state of
>        the "Work on current page only" item of the Options menu.
>
>    */
#line event.c:6010 (book)
>    /* (book)
>
>        Generate spelling hints
>
>        Remark: this is not implemented yet.
>
>        Start filtering through ispell to generate
>        transliterations for unknow symbols or alternative
>        transliterations for known symbols. Clara will use the
>        dictionaries available for the languages selected on
>        the Languages menu. Filtering will be performed on the
>        current page or on all pages, depending on the state of
>        the "Work on current page only" item of the Options menu.
>
>    */
#line event.c:6027 (book)
>    /* (book)
>
>        Generate output
>
>        The OCR output is generated to be displayed on the
>        "PAGE (output)" window. The output is also saved to the
>        file page.html.
>    */
#line event.c:6037 (book)
>    /* (book)
>
>        Generate web doubts
>
>        Files containing symbols to be revised through the web
>        interface are created on the "doubts" subdirectory of
>        the work directory. This step is performed only when
>        Clara OCR is started with the -W command-line switch.
>    */
#line event.c:6049 (book)
>    /* (book)
>
>        PAGE options menu
>        -----------------
>
>        This menu is activated when the mouse button 3 is pressed on
>        the PAGE window.
>
>    */
#line event.c:6061 (book)
>    /* (book)
>
>        See in fatbits
>
>        Change to PAGE_FATBITS focusing this symbol.
>    */
#line event.c:6069 (book)
>    /* (book)
>
>        Bottom left here
>
>        Scroll the window contents in order to the
>        current pointer position become the bottom left.
>    */
#line event.c:6078 (book)
>    /* (book)
>
>        Use as pattern
>
>        The pattern of the class of this symbol will be the unique
>        pattern used on all subsequent symbol classifications. This
>        feature is intended to be used with the "OCR this symbol"
>        feature, so it becomes possible to choose two symbols to
>        be compared, in order to test the classification routines.
>
>    */
#line event.c:6091 (book)
>    /* (book)
>
>        OCR this symbol
>
>        Starts classifying only the symbol under the pointer. The
>        classification will re-scan all patterns even if the "re-scan
>        all patterns" option is unselected.
>    */
#line event.c:6101 (book)
>    /* (book)
>
>        Merge with current symbol
>
>        Merge this fragment with the current symbol.
>    */
#line event.c:6109 (book)
>    /* (book)
>
>        Link as next symbol
>
>        Create a symbol link from the current symbol (the one
>        identified by the graphic cursor) to this symbol.
>    */
#line event.c:6118 (book)
>    /* (book)
>
>        Disassemble symbol
>
>        Make the current symbol nonpreferred and each of its
>        components preferred.
>    */
#line event.c:6127 (book)
>    /* (book)
>
>        Link as accent
>
>        Create an accent link from the current symbol (the one
>        identified by the graphic cursor) to this symbol.
>    */
#line event.c:6136 (book)
>    /* (book)
>
>        Diagnose symbol pairing
>
>        Run locally the symbol pairing heuristic to try to join
>        this symbol to the word containing the current symbol.
>        This is useful to know why the OCR is not joining two
>        symbols on one same word.
>    */
#line event.c:6147 (book)
>    /* (book)
>
>        Diagnose word pairing
>
>        Run locally the word pairing heuristic to try to join
>        this word with the word containing the current symbol
>        on one same line. This is useful to know why the OCR is
>        not joining two words on one same line.
>    */
#line event.c:6158 (book)
>    /* (book)
>
>        Diagnose lines
>
>        Run locally the line comparison heuristic to decide
>        which is the preceding line.
>    */
#line event.c:6167 (book)
>    /* (book)
>
>        Diagnose merging
>
>        Run locally the geometrical merging heuristic to try
>        to merge this piece to the current symbol.
>    */
#line event.c:6176 (book)
>    /* (book)
>
>        Show pixel coords
>
>        Present the coordinates and color of the current pixel.
>    */
#line event.c:6185 (book)
>    /* (book)
>
>        Show closures
>
>        Identify the individual closures when displaying the
>        current document.
>    */
#line event.c:6194 (book)
>    /* (book)
>
>        Show symbols
>
>        Identify the individual symbols when displaying the
>        current document.
>    */
#line event.c:6203 (book)
>    /* (book)
>
>        Show words
>
>        Identify the individual words when displaying the
>        current document.
>    */
#line event.c:6212 (book)
>    /* (book)
>
>        Show pattern type
>
>        Display absent symbols on pattern type 0, to help
>        building the bookfont.
>    */
#line event.c:6221 (book)
>    /* (book)
>
>        Report scale
>
>        Report the scale on the tab when the PAGE window is
>        active.
>    */
#line event.c:6231 (book)
>    /* (book)
>
>        Display box instead of symbol
>
>        On the PAGE window displays the bounding boxes instead of
>        the symbols themselves. This is useful when designing new
>        heuristics.
>    */
#line event.c:6241 (book)
>    /* (book)
>
>        PAGE_FATBITS options menu
>        -------------------------
>
>        This menu is activated when the mouse button 3 is pressed on
>        the PAGE.
>
>    */
#line event.c:6252 (book)
>    /* (book)
>
>        Bottom left here
>
>        Scroll the window contents in order to the
>        current pointer position become the bottom left.
>    */
#line event.c:6261 (book)
>    /* (book)
>
>        Centralize
>
>        Scroll the window contents in order to the
>        centralize the closure under the pointer.
>    */
#line event.c:6270 (book)
>    /* (book)
>
>        Build border path
>
>        Build the closure border path and activate the flea.
>    */
#line event.c:6278 (book)
>    /* (book)
>
>        Search straight lines (linear)
>
>        Build the closure border path and search straight lines
>        there using linear distances.
>    */
#line event.c:6287 (book)
>    /* (book)
>
>        Search straight lines (quadratic)
>
>        Build the closure border path and search straight lines
>        there using correlation.
>    */
#line event.c:6296 (book)
>    /* (book)
>
>        Is bar?
>
>        Apply the isbar test on the closure.
>    */
#line event.c:6304 (book)
>    /* (book)
>
>        Detect extremities?
>
>        Detect closure extremities.
>    */
#line event.c:6312 (book)
>    /* (book)
>
>        Show skeletons
>
>        Show the skeleton on the windows PAGE_FATBITS. The
>        skeletons are computed on the fly.
>    */
#line event.c:6322 (book)
>    /* (book)
>
>        Show border
>
>        Show the border on the window PAGE_FATBITS. The
>        border is computed on the fly.
>    */
#line event.c:6331 (book)
>    /* (book)
>
>        Show pattern skeleton
>
>        For each symbol, will show the skeleton of its best match
>        on the PAGE (fatbits) window.
>    */
#line event.c:6340 (book)
>    /* (book)
>
>        Show pattern border
>
>        For each symbol, will show the border of its best match
>        on the PAGE (fatbits) window.
>    */
#line event.c:6350 (book)
>    /* (book)
>
>        Alphabets menu
>        --------------
>
>        This item selects the alphabets that will be available on the
>        alphabets button.
>    */
#line event.c:6360 (book)
>    /* (book)
>
>        Arabic
>
>        This is a provision for future support of Arabic
>        alphabet.
>    */
#line event.c:6369 (book)
>    /* (book)
>
>        Cyrillic
>
>        This is a provision for future support of Cyrillic
>        alphabet.
>    */
#line event.c:6378 (book)
>    /* (book)
>
>        Greek
>
>        This is a provision for future support of Greek
>        alphabet.
>    */
#line event.c:6387 (book)
>    /* (book)
>
>        Hebrew
>
>        This is a provision for future support of Hebrew
>        alphabet.
>    */
#line event.c:6396 (book)
>    /* (book)
>
>        Kana
>
>        This is a provision for future support of Kana
>        alphabet.
>    */
#line event.c:6405 (book)
>    /* (book)
>
>        Latin
>
>        Words that use the Latin alphabet include those from
>        the languages of most Western European countries (English,
>        German, French, Spanish, Portuguese and others).
>    */
#line event.c:6415 (book)
>    /* (book)
>
>        Number
>
>        Numbers like
>        1234, +55-11-12345678 or 2000.
>    */
#line event.c:6425 (book)
>    /* (book)
>
>        Ideogram
>
>        Ideograms.
>    */
#line event.c:6435 (book)
>    /* (book)
>
>        Languages menu
>        --------------
>
>        This menu selects the languages used on the book. It will
>        define the dictionaries that will be applied when trying
>        to generate the transliteration of unknown symbols or
>        generating alternative transliterations or marking a
>        word for future revision.
>    */
#line event.c:6448 (book)
>    /* (book)
>
>        English (USA)
>
>        Toggle American English spell checking for
>        each word found on the page.
>    */
#line event.c:6457 (book)
>    /* (book)
>
>        English (UK)
>
>        Toggle British English spell checking for
>        each word found on the page.
>    */
#line event.c:6466 (book)
>    /* (book)
>
>        French
>
>        Toggle French spell checking for
>        each word found on the page.
>    */
#line event.c:6475 (book)
>    /* (book)
>
>        German
>
>        Toggle german spell checking for
>        each word found on the page.
>    */
#line event.c:6484 (book)
>    /* (book)
>
>        Greek
>
>        Toggle greek spell checking for
>        each word found on the page.
>    */
#line event.c:6493 (book)
>    /* (book)
>
>        Portuguese (Brazil)
>
>        Toggle brazilian protuguese spell checking for
>        each word found on the page.
>    */
#line event.c:6502 (book)
>    /* (book)
>
>        Portuguese (Portugal)
>
>        Toggle Portuguese spell checking for
>        each word found on the page.
>    */
#line event.c:6511 (book)
>    /* (book)
>
>        Russian
>
>        Toggle Russian spell checking for
>        each word found on the page.
>    */
#line event.c:6522 (book)
>    /* (book)
>
>        Options menu
>        ------------
>    */
#line event.c:6529 (book)
>    /* (book)
>
>        Work on current page only
>
>        OCR operations (classification, merge, etc) will be
>        performed only on the current page.
>    */
#line event.c:6538 (book)
>    /* (book)
>
>
>        Work on all pages
>
>        OCR operations (classification, merge, etc) will be
>        performed on all pages.
>    */
#line event.c:6548 (book)
>    /* (book)
>
>        Emulate deadkeys
>
>        Toggle the emulate deadkeys flag. Deadkeys are useful for
>        generating accented characters. Deadkeys emulation are disabled
>        by default The emulation of deadkeys may be set on startup
>        through the -i command-line switch.
>    */
#line event.c:6560 (book)
>    /* (book)
>
>        Menu auto popup
>
>        Toggle the automenu feature. When enabled, the menus on the
>        menu bar will pop automatically when the pointer reaches
>        the menu bar.
>    */
#line event.c:6570 (book)
>    /* (book)
>
>        PAGE only
>
>        When selected, the PAGE tab will display only the PAGE window. The
>        windows PAGE_OUTPUT and PAGE_SYMBOL will be hidden.
>    */
#line event.c:6579 (book)
>    /* (book)
>
>        DEBUG menu
>        ----------
>
>    */
#line event.c:6587 (book)
>    /* (book)
>
>        Show unaligned symbols
>
>        The symbols with unknown alignment are displayed using gray
>        ellipses. This option overrides the "show current class"
>        feature.
>    */
#line event.c:6597 (book)
>    /* (book)
>
>        Show localbin progress
>
>        Display the progress of the extraction of symbols
>        performed by the local binarizer.
>    */
#line event.c:6606 (book)
>    /* (book)
>
>        Activate Abagar
>
>        Abagar is a powerful debug mode used to detect binarization
>        problems. It works as follows: first load a pgm image and create
>        a zone around the problematic region (typically a single letter).
>        Now make sure the "Activate Agabar" option (debug menu) is on,
>        and ask segmentation. Various operations will dump data when
>        the segmentation enters the zone.
>
>    */
#line event.c:6620 (book)
>    /* (book)
>
>        Show lines (geometrical)
>
>        Identify the lines (computed using geometrical criteria)
>        when displaying the current document.
>    */
#line event.c:6629 (book)
>    /* (book)
>
>        Bold Only
>
>        Restrict the show symbols or show words feature
>        (PAGE menu) to bold symbols or words.
>    */
#line event.c:6639 (book)
>    /* (book)
>
>        Italic Only
>
>        Restrict the show symbols or show words feature
>        (PAGE menu) to bold symbols or words.
>    */
#line event.c:6648 (book)
>    /* (book)
>
>        Search unexpected mismatches
>
>        Compare all patters with same type and transliteration. Must
>        be used with the "Show comparisons and wait" option on
>        to diagnose symbol comparison problems.
>    */
#line event.c:6659 (book)
>    /* (book)
>
>        Attach vocab.txt
>
>        Attach the contents of the file vocab.txt of the current
>        directory (if any) to the DEBUG window. Used to test the
>        text analisys code.
>    */
#line event.c:6670 (book)
>    /* (book)
>
>        Attach log
>
>        Attach the contents of message log to the DEBUG window.
>        Used to inspect the log.
>    */
#line event.c:6679 (book)
>    /* (book)
>
>        Reset match counters
>
>        Change to zero the cumulative matches field of all
>        patterns.
>    */
#line event.c:6689 (book)
>    /* (book)
>
>        Enter debug window
>
>    */
#line symbol.c:33 (book)
>/* (book)
>
>Pixel number threshold. To bitmaps p and q match, the condition
>(PNT*abs(np-nq) <= (np+nq)) must hold, where np and nq are the
>number of pixels of p and q. The first pass uses PNT1, and, the
>second, PNT2.
>
>The default values for PNT1 and PNT2 may be changed through the -P
>command-line switch. You want PNT2 < PNT1 to make the entire process
>faster (so the first pass will recognize the "easier" characters and,
>the second, the others).
>
>*/
#line symbol.c:633 (book)
>/* (book)
>
>Alignment tuning
>----------------
>
>At this point, we can generate the output for all pages. The
>output is already available if the classification was performed
>clicking the OCR button with mouse button 1. If not, just select
>the "Work on all pages" item on the "Options" menu, and click the
>OCR button using the mouse button 1. The per-page output will be
>saved to the files 5.html and 6.html.
>
>Maybe the output will contain unknow symbols. Maybe the output
>presents broken lines or broken words. If so, the numbers used to
>perform symbol alignment must be changed. These numbers are
>configured on the TUNE tab ("Magic numbers" section). They're
>part of the session data, so they'll be saved to disk.
>
>There are 7 such numbers:
>
>    max word distance as percentage of x_height
>    max symbol distance as percentage of x_height
>    dot diameter measured in millimeters
>    max alignment error as percentage of DD
>    descent (relative to baseline) as percentage of DD
>    ascent (relative to baseline) as percentage of DD
>    x_height (relative to baseline) as percentage of DD
>    steps required to complete the unity
>
>In order to understand why these numbers are relevant, suppose,
>for instance, that Clara OCR already knows that the "b" symbol
>below is a letter "b", but does not know that the "p" symbol is a
>letter "p". To decide if the "p" symbol seems to be a letter
>instead of a blot, Clara OCR checks if it fits the the typical
>dimensions of a letter. To do so, alignemnt hints are needed. On
>the figure we can see the baseline-relative ascent (AS), descent
>(DS) and x_height (XH), and the dot diameter (DD).
>
>
>    XXX                          --\--
>     XX                            |
>     XX                            |
>     XX                            |
>     XX XXXXX   XX  XXXXX          |     --\--
>     XXX     X   XXX     X         | AS    |  
>     XX      XX  XX      XX        |       |  
>     XX      XX  XX      XX        |       | XH  
>     XX      XX  XX      XX        |       |  
>     XX      XX  XX      XX  X     |       |     --\--
>     XXX     X   XXX     X  XXX    |       |       | DD
>     XX XXXXX    XX XXXXX    X   --\--   --\--   --\--
>                 XX                |
>                 XX                | DS
>                 XX                |
>                XXXX             --\--
>
>
>The most relevant numbers to configure are the dot diameter, the
>maximum alignment error, the descent, the ascent and the x_height.
>They inform the baseline-relative ascent, descent and x_height, as
>percentages of the dot diameter. The usage of these numbers is
>expected to stop some day in the future, when the pattern types
>implementation become more mature.
>
>*/
#line symbol.c:923 (devel)
>/* (devel)
>
>Symbol pairing
>--------------
>
>Pairing applies to letters and digits. We say that the symbols a and b
>(in this order) are paired if the symbol b follows the symbol a within
>one same word. For instance, "h" and "a" are paired on the word
>"that", "3" and "4" are paired on "12345", but "o" and "b" are not
>paired on "to be" (because they're not on the same word).
>
>The function s_pair tests symbol pairing, and returns
>the following diagnostics:
>
>0 .. the symbols are paired
>1 .. insuficcient vertical intersection
>2 .. one or both symbols above ascent
>3 .. one or both symbols below descent
>4 .. maximum horizontal distance exceeded
>5 .. incomplete data
>6 .. different zones
>
>If p is nonzero, then store the inferred alignment for each symbol
>(a and b) on the va field of these symbols, except when these
>symbols have the va field already defined.
>
>If rd is non-null, returns the dot diameter in *rd. If an
>estimative for the dot diameter cannot be computed, does not
>change *rd.
>
>*/
#line symbol.c:1492 (devel)
>/* (devel)
>
>
>Transliteration preference
>--------------------------
>
>The election process used to choose the "best" transliteration for one
>symbol (from those obtained through human revision or heuristics based
>on shape similarity or spelling) consists in computing the
>"preference" of each transliteration and choosing the one with maximum
>preference.
>
>The transliteration preference is the integer
>
>    UTSEAN
>
>where
>
>U is 1 if the transliteration was confirmed by the arbiter,
>or 0 otherwise.
>
>T is 0 if this transliteration was confirmed by no trusted
>source, 1 if it was confirmed by some trusted source.
>
>S is 0 if this transliteration was not shape-deduced
>from trusted input, or 1 if it was shape-deduced
>from trusted input.
>
>E is 1 if this transliteration was deduced from spelling,
>or 0 otherwise.
>
>A is 0 if this transliteration was confirmed by no anon
>source, 1 if it was confirmed by some anon source.
>
>N is 0 if this transliteration was not shape-deduced
>from anon input, or 1 if it was shape-deduced from anon input.
>
>
>Transliteration class computing
>-------------------------------
>
>Once we have computed the "best" transliteration, we can compute
>its transliteration class, important for various heuristics. From
>the transliteration class it's possible test things like "do we
>know the transliteration of this symbol?" or "is it an
>alphanumeric character?"  or "concerning dimension and vertical
>alignment could it be an alphanumeric character?", and others.
>
>There are two moments where the transliteration class is
>computed. The first is when a transliteration is added to
>the symbol, and the second is when the CHAR class is
>propagated.
>
>The first uses the following criteria to compute the
>transliteration class:
>
>1. If the symbol has no transliteration at all, its class is
>UNDEF.
>
>2. On all other cases, the transliteration with largest
>preference will be classified as DOT, COMMA, NOISE, ACCENT and
>others. This search is implemented by the classify_tr function in
>a straightforward way.
>
>Just before the distribution of all symbols on words we propagate
>CHARs. All CHAR symbols are searched, and for each one we look
>its neighbours that seem to compose with it one same word. Such
>neighbours, if untransliterated, will be classified as SCHARs.
>
>*/
#line symbol.c:1890 (devel)
>/* (devel)
>
>    How to add a bitmap comparison method
>    -------------------------------------
>
>    It's not hard to add a bitmap comparison method to Clara
>    OCR. This may become very important when the available
>    heuristics are unable to classify the symbols of some
>    book, so a new heuristic must be created. In order to exemplify
>    that, we'll add a naive bitmap comparison method. It'll
>    just compare the number of black pixels on each bitmap,
>    and consider that the bitmaps are similar when these
>    numbers do not differ too much.
>
>    Please remember that the code added or linked to Clara
>    OCR must be GPL.
>
>    In order to add the new bitmap comparison method, we need
>    to write a function that compares two bitmaps returning how
>    similar they are, add this function as an alternative to
>    the Options menu, and call it when classifying the page symbols.
>    We'll perform all these steps adding a naive comparison
>    method, step by step. The more difficult one is to write
>    the bitmap comparison method. This step is covered on the
>    subsection "How to write a bitmap comparison function".
>
>    Let's present the other two steps. To add the new method
>    to the Options menu, we need:
>
>    a. Declare the macro CL_NBP:
>
>      #define CL_BM 2
>
>    b. Include the new classifier on the tune form (function
>    mk_tune):
>
>      C = (classifier==CL_NBP) ? "CHECKED" : "";
>      ..
>
>    Now add the call to
>    this new method on the classifier. This is just a matter of
>    adding one more item on the function selbc:
>
>      else if (classifier == NBP)
>          r = classify(c,bmpcmp_nbp,1);
>
>    Where bmpcmp_nbp is the function that will be discussed
>    on the subsection "How to write a bitmap comparison function".
>
>    To use the new method, recompile the sources, start
>    Clara OCR and select the new method on the tune tab.
>*/
#line symbol.c:2058 (devel)
>    /* (devel)
>
>        How to write a bitmap comparison function
>        -----------------------------------------
>
>        The bitmap comparison function required for the example we're
>        presenting has the following prototype:
>
>            int bmpcmp_nbp(int c,int st,int k,int d)
>
>        The first parameter (c) is the symbol being compared, the
>        second (st) is the current status, the third (k) is the current
>        pattern and the fourth (d) will be discussed later.
>
>    */
#line symbol.c:2074 (devel)
>    /* (devel)
>
>        Clara OCR will call bmpcmp_nbp once informing status 1
>        every time a new symbol c is chosen, so bmpcmp_cp
>        will be able to bufferize symbol data on static areas.
>        Note that to classify each symbol, Clara will
>        perform various calls to the bitmap
>        comparison function, because it will check X events
>        (like the STOP button), and, when visual modes are
>        enabled, Clara will need to refresh the screen
>        displaying the progress of the classification.
>
>        The block of bmpcmp_nbp corresponding to status 1 will
>        merely store on the static variable np the value of
>        the nbp field of the symbol structure.
>
>            nbp = mc[c].nbp;
>    */
#line symbol.c:2096 (devel)
>    /* (devel)
>
>        Before trying to classify the symbol c as similar to the
>        pattern k, Clara allows the bitmap comparison method to
>        apply simple heuristics to filter bad candidates in order
>        to save CPU cycles. This is done informing status 2. The
>        bitmap comparison function is expected, in this caso, to
>        return 1 if the pattern was accepted for further
>        processing, or 0 if it was rejected. For simplicity, the
>        bmpcmp_nbp function will return 1 in all cases.
>    */
#line symbol.c:2111 (devel)
>    /* (devel)
>
>        When Clara OCR wants to effectively ask if the pattern
>        k matches the symbol c, it calls the bitmap comparison
>        function informing status 3. The function must return
>        a similarity index ranging from 0 (no similarity) to
>        10 (identity). Now we must take care of the fourth
>        parameter (mode). It informs if Clara is asking for a direct
>        (mode == 1) comparison or indirect (mode == 0) comparison.
>        This applies for asymmetric comparison methods. For
>        instance, when using skeleton fitting, "direct" means
>        that the pattern skeleton fits the symbol, and "indirect"
>        means that the symbol skeleton fits the pattern. Clara
>        will make both calls to avoid false positives.
>
>        In our example we'll on both cases return 10 if the test
>        5 * abs(nbp-m) <= (nbp+m) results true, where m is the
>        number of black pixels of the pattern.
>
>            m = pattern[k].nbp;
>            if ((5*abs(nbp-)) <= (d->bp+mc[c].nbp))
>                return(10);
>            else
>                return(0)
>    */
#line symbol.c:2144 (devel)
>    /* (devel)
>
>        Finally, every bitmap comparison method is expected to
>        produce a graphic image of the current status of the
>        comparison when called with status 0. That
>        image must be an FSxFS bitmap where each pixel may assume
>        the color WHITE, BLACK or GRAY. This bitmap must be
>        stored on the cfont array of bytes. The pixel on line i
>        and column j must be put on cfont[i+j*FS]. In our case
>        we'll just call the services copy_mc and bm2byte. The
>        effect is to copy the symbol bitmap to the cfont array:
>
>            unsigned char mcbm[BMS];
>            [...]
>            copy_mc(mcbm,c);
>            bm2byte(cb,mcbm);
>
>    */
#line symbol.c:4438 (devel)
>/* (devel)
>
>The function list_cl
>--------------------
>
>The function list_cl lists all closures that intersect the rectangle
>of height h and width w with top left (x,y). The result will be
>available on the global array list_cl_r, on indexes
>0..list_cl_sz-1. This service is used to clip the closures or symbols
>(see list_s) currently visible on the PAGE window. It's also used by
>OCR operations that require locating the neighbours of one closure or
>symbol (see list_s).
>
>The parameter reset must be zero on all calls, except on the very
>first call of this function after loading one page.
>
>Every time a new page is loaded, this service must be called
>informing a nozero value for the reset parameter. In this case,
>the other parameters (x, y, w and h) are ignored, and the effect
>will be preparing the page-specific static data structures used
>to speed up the operation.
>
>Closures are located by list_cl from the static lists of closures
>clx and cly, ordered by leftmost and topmost coordinates. Small
>and large closures are handled separately. The number of closures
>with width larger than FS is counted on nlx. The number of
>closures with height larger than FS is counted on nly.
>
>The clx array is divided in two parts. The left one contains
>(topcl+1)-nlx indexes for the closures with width not larger than
>FS, sorted by the leftmost coordinate. The right one contains the
>other indexes, in descending order.
>
>The cly array is divided in two parts. The left one contains
>(topcl+1)-nly indexes for the closures with height not larger
>than FS, sorted by the topmost coordinate. The right one contains
>the other indexes, in descending order.
>
>So the small closures on the rectangle (x,y,w,h) may be located
>through a combination of bynary searches on both axis. The large
>closures are located by a brute-force linear loop. As nlx and nly
>are expected to be very small, this brute force loop won't waste
>CPU time.
>
>*/
#line pbm2cl.c:67 (devel)
>/* (devel)
>
>Bitmaps
>-------
>
>Clara stores bitmaps in a linear array of bytes, following
>closely the pbm raw format. The first line of a bitmap with width
>w is stored on the first (w/8)+((w%8)!=0) bytes of the array. The
>remaining bits (if any) are left blank, and so on. The leftmost
>bit on each byte is the most significative one (black, or "on",
>is 1, and white, or "off" is 0). An example follows:
>
>       76543210765432
>      +--------------+
>      |              | 00000000 00000000 =  0   0
>      |   XX XXXX    | 00011011 11000000 = 27 192
>      |    XX   XX   | 00001100 01100000 = 12  96
>      |    XX   XX   | 00001100 01100000 = 12  96
>      |    XX   XX   | 00001100 01100000 = 12  96
>      |    XX   XX   | 00001100 01100000 = 12  96
>      |              | 00000000 00000000 =  0   0
>      +--------------+
>
>      stored as: 0 0 27 192 12 96 12 96 12 96 12 96 0 0
>
>Note that the array of bytes that encodes one bitmap does not
>contain the bitmap width nor the height. So bitmaps must be
>stored together with other data. This is done by structures where
>the bitmap is one field and the geometric information is stored
>on other fields. There are two such structures: bdesc and
>cldesc.
>
>*/
#line redraw.c:112 (devel)
>/* (devel)
>
>Geometry of the application window
>----------------------------------
>
>The source code frequently refers some global variables that define
>the position and size of the main componts (the plate, buttons,
>etc). Most of these variables are set by comp_wnd_size. The variables
>are:
>
>    WH  .. application window height
>    WW  .. application window width
>    PH  .. plate height
>    PW  .. plate width
>    BW  .. button width
>    BH  .. button width
>    MRF .. maximum reduction factor
>    TW  .. tab width
>    TH  .. tab height
>    PM  .. plate horizontal margin
>    PT  .. plate top margin
>    RW  .. scrollbar width
>    MH  .. menubar heigth
>
>MRF applies to the scanned document and to the web clip.
>
>*/
#line redraw.c:4353 (devel)
>/* (devel)
>
>The function setview
>--------------------
>
>As each window is displayed on only one mode and each mode belongs
>to only one tab, in order to set a given mode or a given tab,
>just call setview informing one window present on that mode as
>parameter. That is the only parameter received by setview.
>The geometry of each window will be re-computed by setview, so
>setview is not called only to change the current mode, but
>also after operations that change the geometry of the windows,
>just like resizing the application X window or hiding the
>scrollbars, or resizing the PAGE window, etc.
>
>*/
#line html.c:373 (devel)
>/* (devel)
>
>HTML windows overview
>---------------------
>
>Clara is able to read a piece of HTML code, render it, display
>the rendered code, and attend events like selection of an anchor,
>filling a text field, or submitting a form. Note that anchor
>selection and form submission activate internal procedures, and
>won't call external customizable CGI programs.
>
>Most windows displayed by Clara are produced using this HTML
>support. When the "show HTML source" option on the "View" menu is
>selected, Clara will display unrendered HTML, and it will become
>easier to identify the HTML windows. Note that all HTML is
>produced by Clara itself. Clara won't read HTML from files or
>through HTTP.
>
>Perhaps you are asking why Clara implements these things. Clara
>does not intend to be a web browser. Clara supports HTML because
>we were in need of a forms interface, and the HTML forms is
>around there, ready to be used, and extensively proved on
>practice as an easy and effective solution.  Note that we're not
>trying to achieve completeness. Clara HTML support is
>partial. There is only one font available, tables cannot be
>nested and most options are unavailable, PBM is the only graphic
>format supported, etc. However, it attends our needs, and the
>code is surprisingly small.
>
>Let's understand how the HTML windows work. First of all, note
>that there is a html flag on the structure that defines a window
>(structure dwdesc). For instance, this flag is on for the window
>OUTPUT (initializition code at function setview).
>
>When the function redraw is called and the window OUTPUT is
>visible on the plate, the service draw_dw will be called
>informing OUTPUT through the global variable CDW (Current
>Window). However, before making that, redraw will test the flag
>RG to check if the HTML contents for the OUTPUT window must be
>generated again, calling a function specific to that window. For
>instance, when a symbol is trained, this flag must be set in
>order to notify asynchronously the need to recompute the window
>contents, and render it again.
>
>HTML renderization is performed by the function html2ge. It will
>create an array of graphic entities. Each such entity is a
>structure informing the geometric position (x,y,width,height) of
>something, and this something (a piece of text, a button and its
>label and state, a PBM image, etc). Finally, the function
>draw_dw will search the elements currently visible on the
>portion of the document clipped by the window, and display them.
>
>*/
#line html.c:2899 (book)
>/* (book)
>
>
>Analysing the statistics
>------------------------
>
>The "page (list)" tab offers recognition statistics on a per-page
>basis. The contents of each column on this tab is described
>below:
>
>POS: The sequential position on the list. The current page
>is informed by an asterisk on this column.
>
>FILE: The name of the file that contains the PBM image of the
>document.
>
>RUNS: The number of OCR runs on this page. Partial OCR runs,
>like classification (started by the "classify" button also count
>as one run.
>
>TIME: Total CPU time wasted with OCR operations on this
>page. I/O time (reading and saving session files) is not
>included.
>
>WORDS: Current number of words on this page. This variable is
>updated by the "build" step.
>
>SYMBOLS: Current number of symbols on this page. This variable
>is updated by the "build" step.
>
>DOUBTS: Current number of untransliterated CHAR symbols on
>this page. This variable is updated by the "build" step.
>
>CLASSES: Current number of classes on this page.
>
>FACT: Quotient between the number of symbols and the number of
>classes.
>
>RECOG: Quotient between (symbols-doubts) and symbols, where
>"symbols" is the number of symbols and "doubts" is the number of
>doubts as defined above.
>
>PROGRESS: difference between the current recog rate and the
>recog rate for the previous run.
>
>*/
#line revision.c:97 (devel)
>    /* (devel)
>
>        The function review_tr
>        ----------------------
>
>        Process the submission of transliterations. Also
>        process the actions that change the properties of the
>        current symbol. This is not a simple operation. In
>        order to make the interface powerful, the submission of
>        a transliteration may change the transliteration of the
>        current symbol, and also the transliterations of all
>        symbols on its class. Depending on the properties,
>        other actions may be performed as well.
>
>    */
#line revision.c:248 (devel)
>    /* (devel)
>
>        0. Remove the current revision vote (if any).
>
>    */
#line revision.c:260 (devel)
>    /* (devel)
>
>        1. Add a REVISION vote for the current symbol,
>        informing the submitted transliteration, and compute
>        the preferred transliteration considering this new
>        vote.
>
>    */
#line revision.c:271 (devel)
>    /* (devel)
>
>        2. If the symbol is unclassified or if the transliteration
>        differ from the class transliteration then add its bitmap
>        as a pattern, unless it's bad or too large.
>    */
#line revision.c:291 (devel)
>    /* (devel)
>
>        3. If the symbol is classified and the class is untransliterated
>        or if the user asked to change the class transliteration, then
>        propagate the submitted transliteration to the entire class.
>    */
#line revision.c:316 (devel)
>    /* (devel)
>
>        4. If the symbol is classified, it is not the pattern of
>        the class, and it was not bad, but it became bad now,
>        then remove it from its class, and remove its SHAPE vote.
>    */
#line revision.c:327 (devel)
>    /* (devel)
>
>        5. If the symbol is the pattern of the class, and it
>        was not bad, but it became bad now, then remove it from
>        the patterns.
>    */
#line revision.c:364 (devel)
>    /* (devel)
>
>        The function review_patt
>        ------------------------
>
>    */
#line build.c:956 (devel)
>        /* (devel)
>
>            The build step
>            --------------
>
>            The "build" OCR step, implemented by the "build"
>            function, distributes the symbols on words
>            (analysing the distance, heights and relative
>            position for each pair of symbols), and the words
>            on lines (analysing the distance, heights and
>            relative position for each pair of words). Various
>            important heuristics take effect here.
>
>            0. Preparation
>
>            The first step of build is to distribute the symbols
>            on words. This is achieved by:
>
>            a. Undefining the next-symbol ("E" field) and previous-symbol
>            ("W" field) links for each symbol, the surrounding word ("sw"
>            field) of each symbol, and the next signal ("sl" field) for
>            each symbol.
>
>            Remark: The next-symbol and previous symbol links are used
>            to build the list of symbols of each word. For instance,
>            on the word "goal", "o" is the next for "g" and
>            the previous for "a", "g" has no previous and "l"
>            has no next).
>
>        */
#line build.c:990 (devel)
>        /* (devel)
>
>            b. Undefining the transliteration class of SCHARs and
>            the uncertain alignment information.
>
>        */
#line build.c:1017 (devel)
>        /* (devel)
>
>            2. Distributing symbols on words
>
>            The second step is, for each CHAR not in any word, define
>            a unitary word around it, and extend it to right
>            and left applying the symbol pairing test.
>
>        */
#line build.c:1160 (devel)
>        /* (devel)
>
>            3. Computing the alignment using the words
>
>            Some symbols do not have a well-defined alignment by
>            themselves. For instance, a dot may be baseline-aligned
>            (a final dot) or 0-aligned (the "i" dot). So when
>            computing their alignments, we need to analyse their
>            neighborhoods. This is performed in this step.
>
>        */
#line build.c:1250 (devel)
>        /* (devel)
>
>            4. Validating the recognition
>
>            Shape-based recognitions must be validated by special
>            heuristics. For instance, the left column of a broken 
>            "u" may be recognized as the body of an "i" letter. A
>            validation heuristic may refuse this recognition for
>            instance because the dot was not found. These heuristics
>            are per-alphabet.
>
>        */
#line build.c:1278 (devel)
>        /* (devel)
>
>            5. Creating fake words for punctuation signs
>
>            To produce a clean output, symbols that do not belong to
>            any word are not included on the OCR output. So we need
>            to create fake words for punctuation signs like commas
>            of final dots.
>
>        */
#line build.c:1336 (devel)
>        /* (devel)
>
>            6. Aligning words
>
>            Words need to be aligned in order to detect the
>            page text lines. This is perfomed as follows:
>
>        */
#line build.c:1351 (devel)
>        /* (devel)
>
>            a. Undefine the next-word and previous-word
>            links for each word. These are links for the
>            previous and next word within lines. For instance,
>            on the line "our goal is", "goal" is the next
>            for "our" and the previous for "is", "our" has
>            no previous and "is" has no next.
>        */
#line build.c:1365 (devel)
>        /* (devel)
>
>            b. Distribution of the words on lines. This is just
>            a matter of computing, for each word, its "next" word.
>            So for each pair of words, we test if they're "paired"
>            in the sense of the function w_pair. In affirmative
>            case, we make the left word point to the right word
>            as its "next" and the rigth point to the left as its
>            "previous".
>
>            The function w_pair does not test the existence of
>            intermediary words. So on the line "our goal is" that
>            function will report pairing between "our" and "is".
>            So after detecting pairing, our loop also checks if the
>            detected pairing is eventually "better" than those
>            already detected.
>
>        */
#line build.c:1479 (devel)
>        /* (devel)
>
>            c. Sort the lines. The lines are sorted based on the
>            comparison performed by the function "cmpln".
>
>        */
#line build.c:1523 (devel)
>        /* (devel)
>
>            7. Computing word properties
>
>            Finally, word properties can be computed once we
>            have detected the words. Some of these properties are
>            applied to untransliterated symbols. The properties are:
>
>            1. The baseline left and right ordinates.
>
>            2. The italic and bold flags.
>
>            3. The alphabet.
>
>            4. The word bounding box.
>
>            All these properties are computed by the
>            function wprops.
>        */
#line common.h:126 (devel)
>/* (devel)
>
>Return codes
>------------
>
>When Clara OCR exits, the exit code will diagnose the
>finalization status:
>
>  0 clean
>  1 data inconsistency
>  2 buffer overflow
>  3 invalid field
>  4 internal error
>  5 memory exhausted
>  6 X error
>  7 I/O error
>  8 bad input
>
>*/
#line common.h:305 (devel)
>/* (devel)
>
>Global variables
>----------------
>
>Clara OCR uses a lot of global variables. Large data structures,
>flags, paths, etc, use stored on global variables. In some cases we
>use a naming strategy to make the code more readable. The important
>cases are:
>
>a. The main data structures of Clara OCR are global arrays that grow
>as required. The following a convention was created for the names
>associated with these arrays:
>
>    structure    type    array    top    size
>   --------------------------------------------
>    act          adesc   act      topa   actsz
>    closure      cldesc  cl       topcl  clsz
>    symbol       sdesc   mc       tops   ssz
>    pattern      pdesc   pattern  topp   psz
>    link         ldesc   lk       toplk  lksz
>    ptype        ptdesc  pt       toppt  ptsz
>
>The "top" is the last used entry (initial value -1). The "size"
>is the total size of the allocate memory block for that array
>(initial value 0). So the relation (top < size) must always be
>true.
>
>b. Menus are referred by their registration indexes. These indexes are
>stored on variables named CM_X. The menu items registration indexes
>are stored on variables named CM_X_SOMETHING (all capital). If the
>item has an associated flag, the flag is named cm_x_something (all
>small).
>
>*/
#line common.h:341 (devel)
>/* (devel)
>
>Acts and transliterations
>-------------------------
>
>The "acts" or "revision acts" are the human interventions for
>training a symbol, merging a fragment to one symbol, etc.
>
>As the human interventions are the more precious
>source of information, Clara logs all revision acts, in
>order to be able to reuse them.
>
>The transliterations are obtained from the revision acts, so
>each transliteration refers one (or more) revision acts, and
>also inherits some properties from that act (or those acts).
>
>The acts are on the book scope, and not on the page scope. The acts
>are stored on the file "acts" on the work directory.
>
>Each act stores some data about the reviewer and also the submission
>date. As we plan to reuse revision data, each act also stores some
>data about the "original reviewer" and the "original submission
>date". These fields are meaningful only for reused acts.
>
>*/
#line common.h:430 (devel)
>/* (devel)
>
>Symbol transliterations
>-----------------------
>
>Clara OCR maintains a list of 0 or more proposed or deduced
>transliterations for each symbol. Along the OCR process, each
>transliteration receives "votes" from reviewers (REVISION votes)
>or from machine deduction heuristics, based on shape similarity
>(SHAPE votes) or on spelling (SPELLING votes).
>
>So the choice of the "best" transliteration is performed through
>election. Votes are stored on structures of type vdesc, and
>transliterations are stored on structures of type trdesc. Each
>symbol stores a pointer for a (possibly empty) list of
>transliterations and each transliteration stores a pointer
>for a (possibly empty) list of votes.
>
>So, for instance, when one classifier deduces that one symbol is
>"a", it generates a "vote" for the transliteration of that symbol
>to be "a". At the same time, another heuristic could generate
>another vote for the transliteration to be, say, "o". The diagram
>illustrates this situation:
>
>   sdesc  ---> trdesc ("a")  ---> trdesc ("o")
>                 |                  |
>                 +-vdesc            + vdesc
>                 |
>                 +-vdesc
>
>In this case, the transliteration "a" has two votes, one from the
>classifier and another from, say, revision and the transliteration "o"
>has one vote.
>
>As the total stored information about one symbol may be large, Clara
>maintains for each symbol its "transliteration class", used by the
>heuristics to categorize each symbol and also to test the current
>transliteration status (is it known? is it dubious?), frequently used
>along the source code.
>
>*/
#line common.h:482 (devel)
>/* (devel)
>
>Internal representation of pages
>--------------------------------
>
>Even for non-developers, a knowledge of the internal data
>structures used by Clara OCR is required for fine tuning and to
>make simple diagnostics.
>
>The basic elements stored are the "closures". Sets of one or more
>closures are called "symbols". Symbols are arranged in lists
>forming "words". The words are arranged in lists forming "lines".
>
>
>Closures
>--------
>
>Closures of black pixels by contiguity are a first attempt to
>identify the atomic symbols of the document. The name "closure"
>is of course due to the consideration of the contiguity as a
>relation (in the mathematical sense of the word). Starting (for
>instance) from (i,j), we compute the set of black pixels ("X" and
>"*" in the figure). The limits (l,r,t,b) define the bounding box
>of the closure.
>
>          l i    r
>      +---+-+----+---+
>      |              |
>    t +   XX XXXX    |
>      |    XX   XX   |
>    j +    X*   XX   |
>      |    XX   XX   |
>    b +    XX   XX   |
>      |              |
>      +--------------+
>
>When loading a document, the OCR computes all its closures and
>use an array to store them. When the session file is written, the
>closures are stored in CML format. Note that, if required, the
>closures may be recomputed from the document, because the
>document and the closure computing algorithm determine the index
>that each closure will have on the array.
>
>*/
#line common.h:549 (devel)
>/* (devel)
>
>Symbols
>-------
>
>As one character of the document may be composed by two or more
>closures (for instance when it's broken), it's convenient to work not
>with closures, but with sets of closures. So we define the concept of
>"symbol" as being a set of one or more closures. Initially, the OCR
>generates one unitary symbol for each closure. Subsequent steps may
>define new symbols composed by two or more closures.
>
>For instance, let's present three closures that do not correspond
>to atomic symbols: "a" and "i" linked (one closure) and a broken
>"u" (two closures). As a principle, Clara OCR do not try to break
>closures into smaller closures. Instead of that, the
>classification heuristic try to compose various patterns to
>resolve symbols like the "ai" in the figure. Concerning the "u",
>the classification heuristic is expected to merge the two
>closures into one symbol and apply a "u" pattern to resolve it.
>
>
>            l            r     l r l    r
>      +-----+------------+-----+-+-+----+--+
>      |                                    |
>    t +                XX                  |
>      |                XX                  |
>      |                                    |
>      |      XXXXX    XXX      XXX   XXX   + t
>      |     X     XX   XX       XX    XX   |
>      |           XX   XX       XX    XX   |
>      |      XXXXXXX   XX       XX    XX   |
>      |     X     XX   XX       XX    XX   |
>      |     X     XX   XX       XX    XX   |
>    b +      XXXXX XXXXXXX       XX  XXXX  + b
>      |                                    |
>      +------------------------------------+
>
>
>As a principle, Clara OCR won't merge dots and accents into
>characters. So an "i" will generally be formed by two individual
>symbols (the dot and the body). The heuristics that build the OCR
>output are expected to compose these two symbols into one ASC
>character. The same applies for "j" and the accents (acute,
>grave, tilde, etc) found on various european languages.
>
>
>          l  r
>      +---+--+-------+
>      |              |
>    t +    XX        |
>      |    XX        |
>      |              |
>      |   XXX        |
>      |    XX        |
>      |    XX        |
>      |    XX        |
>      |    XX        |
>    b +   XXXX       |
>      |              |
>      +--------------+
>
>
>The preferred symbols
>---------------------
>
>One same closure may belong to more than one symbol. This is
>important in order to allow various heuristic trials. For
>instance, the left closure of the "u" on the preceding section
>could be identified as the body of an "i". In this case however
>we would not find its dot. So the heuristic could try by chance
>another solution, for instance to join it with the nearest
>closure (in that case, the right closure of the "u") and try to
>match it with some pattern of the font.
>
>So the OCR will need to choose, from all symbols that contain a
>given closure, the one to be preferred. In fact, Clara OCR
>maintains dynamically a partition of the set of closures on
>"preferred" symbols. This is the ps array. Some manual
>operations, like fragment merging and symbol disassembling
>(activated by the context menu on the page tab), change that
>partition dinamically, as well as some automatic procedures, like
>the merge step on the OCR run.
>
>
>The sdesc structure and the mc array
>------------------------------------
>
>Each symbol is stored in a sdesc structure. Those structures form
>the mc array. Once created, a symbol is never deleted. So it's
>index on the mc array identifies it (this is important for the
>web-based revision procedure). Note that closures and symbols are
>numbered on a document-related basis. The set of closures that
>define one symbol never changes. So the symbol bounding box and
>the total number of black pixels also won't change either.
>
>So two different entries of the mc array never have the same set
>of closures. The entries of the mc array are created by the
>new_mc service.  When some procedure tries to create a new
>symbol informing a list of closures for which already
>exists a symbol, the service new_mc detects it and returns
>to the caller not the index of a newly created symbol, but
>the index of that already created one.
>
>
>Font size
>---------
>
>The font size is important for classifying all book symbols on
>pattern "types". For instance, books generally use smaller
>letters for footnotes. This classification is performed
>automatically by Clara OCR and presented by the "PATTERN (types)"
>window.
>
>Clara OCR generally uses millimeters for presenting sizes, but
>we'll soon express sizes in "points". Let's see an example. One
>inch corresponds to 72.27 printer's point (pt) (The METAFONTBook
>pg 21, note). So when using 600 dpi, each pt will correspond to
>600/72.27 = 8.3 pixels. For 10 point roman characters, Knuth
>defines the height of lowercase letters as being 155/36 pt, so
>35.7 pixels for us. Therefore, to compute the font size (f) from
>the height in pixels (h) of one lowercase letter, the formula is
>f = 10*h/35.7.
>
>
>Symbol alignment
>----------------
>
>The vertical alignment of symbols is important for various
>heuristics. For instance, the vertical line from a broken "p"
>matches an "l", but using alignement tests we're able to refuse
>this match.
>
>The current Clara OCR alignment support was developed for the Latin
>alphabet, and is being adapted for other alphabets. Four vertical
>alignemnt positions are considered. These positions are referred as
>usual (ascent, baseline and descent). We use the Knuth's identifier
>"x_height" to refer the height of lowercase letters without ascenders.
>
>
>  A XXX                     XXXXXXXXX         
>     XX                      XX      X	       
>     XX                      XX      XX       
>     XX                      XX      XX       
>  X  XX XXXXX   XX  XXXXX    XX      X      XXXX
>     XXX     X   XXX     X   XXXXXXXX     XX    XX
>     XX      XX  XX      XX  XX      X   XX      XX
>     XX      XX  XX      XX  XX      XX  XXXXXXXXXX
>     XX      XX  XX      XX  XX      XX  XX   
>     XX      XX  XX      XX  XX      XX  XX   
>     XXX     X   XXX     X   XX      X    XX    XX  XX
>  B  XX XXXXX    XX XXXXX   XXXXXXXXX       XXXX    XXX
>                 XX                                   X
>                 XX                                   X
>                 XX                                  X
>  D             XXXX                          
>
>
>  A (0) .. ascent (Knuth asc_height)
>  X (1) .. x_height
>  B (2) .. baseline
>  D (3) .. descent (Knuth desc_depth)
>
>So in the figure we say that the alignment of "b" and "B" is 02, the
>alignment of "p" is 13, the alignment of "e" is 12, and the alignment
>of the comma is 23. A period has alignment 22. The dot of an "i" and
>accents have alignment 00. In fact, the positions 1 and 2 use to be
>well defined: all lowercase letters have the same height, and all
>symbols use the same baseline. However, positions 0 and 3 are not so
>well defined. For instance, on some printed books "t" and "l" have
>different heights.
>
>*/
#line common.h:1240 (devel)
>/* (devel)
>
>Words and lines
>---------------
>
>Clara OCR applies The concept of "symbol" to atomic symbols like
>letters, digits or punctuation signs. Words (as "house" or
>"peace"), are handled by Clara OCR as sequences of symbols.
>
>It's very important to compute the words of the page. They
>provide a context both to the OCR and to the reviewer. For
>instance, if the known symbols of some word were identified as
>bold, then Clara will automatically make the bold button on when
>someone tries to review the unknown symbols of that word. The
>same applies to prefer the recognition of one symbol as the digit
>"1" instead of the character "l" if the known symbols of the
>"word" are digits. Words are also the basis for revision based on
>spelling. Each words is stored on a wdesc structure on the "word"
>array.
>
>When building the OCR output, Clara will combine words in
>lines. Each line is a sequence of words (that is, wdesc
>structures). The array "line" is the sequence of the heads of the
>detected lines. Each entry of this array is a lndesc
>structure. The left and right limits of words must be carefully
>computed and compared in order to the OCR partitionate then in
>columns, when dealing with multi-column pages.
>
>*/
#line common.h:1339 (devel)
>/* (devel)
>
>How to add an application button
>--------------------------------
>
>These are the steps to add a new button:
>
>1. Create a new button macro after those already existing (bzoom,
>balpha, etc). Note that each button macro is defined as an unique
>integer (0, 1, 2, etc).
>
>  #define bzoom 0
>  [...]
>  #define bfoo 13
>
>2. Register the new button at init_ds(), together with its
>label. Multi-state buttons have multiple labels, specified as
>"state1:state2:state3":
>
>    register_button(bzoom,"zoom");
>    [...]
>    register_button(bfoo,"foo");
>
>The current state of the new button is stored by
>button[bfoo]. When the state is nonzero, the button is drawn
>using a dark background.
>
>3. Add a new block to attend this button on mactions_b1 and, if
>desired, on mactions_b2 (just copy one existing block and adapt
>it). It's mandatory to attend help requests. On/off and
>multi-state buttons must circulate the acceptable values of the
>respective entry of the array "button" in order to change the
>current state, and set the redraw_button flag.
>
>  if (i == bfoo) {
>      if (help) {
>          show_hint(0,"This is the FOO button");
>          return;
>      }
>      show_hint("You pressed the FOO button");
>  }
>
>There is no need to inform the type of the button (on/off,
>multi-state or event catcher). The behaviour is defined by the
>label and by the attending block. If the attending block changes
>the button state, it must request redraw. Example:
>
>      button[bfoo] = 1 - button[bfoo];
>      redraw_button = bfoo;
>
>*/
#line gui.h:86 (devel)
>/* (devel)
>
>Graphic elements
>----------------
>
>The rendering of each element on the HTML page creates one graphic
>element ("GE" for short).
>
>Free text is rendered to one GE of type GE_TEXT per word. This is
>a "feature". The rendering procedures are currently unable to put
>more than one text word per GE.
>
>IMG tags are rendered to one GE of type GE_IMG. Note that the
>value of the SRC element cannot be the name of a file containing
>a image, but must be "internal" or "pattern/n". These are
>keywords to the web clip and the bitmap the pattern "n". The
>value of the SRC attribute is stored on the "txt" field of the
>GE.
>
>INPUT tags with TYPE=TEXT are rendered to one GE of type
>GE_INPUT. The predefined value of the field (attribute VALUE) is
>stored on the field "txt" of the GE. The name of the field
>(attribute NAME) is stored on the field "arg" of the GE.
>
>The Clara OCR HTML support added INPUT tags with TYPE=NUMBER. They're
>rendered like TYPE=TEXT, but two steppers are added to faster
>selection. So such tags will create three GEs (left stepper, input
>field, and right stepper).
>
>INPUT tags with TYPE=CHECKBOX are rendered to one GE of type
>GE_CBOX. The variable name (attribute NAME) is stored on the "arg"
>field. The argument to VALUE is stored on the field "txt". The status
>of the checkbox is stored on the "iarg" field (2 means "checked", 0
>means "not checked").
>
>INPUT tags with TYPE=RADIO are rendered just like CHECKBOX. The
>only difference is the type GE_RADIO instead GE_CBOX.
>
>SELECT tags (starting a SELECT element) are rendered to one GE of
>type SELECT. In fact, the entire SELECT element is stored on only
>one GE. Each SELECT element originates one standard context menu,
>as implemented by the Clara GUI. The "iarg" field stores the menu
>index. The free text on each OPTION element is stored as an item
>label on the context menu. The implementation of the SELECT
>element is currently buggy: (a) for each renderization, one entry
>on the array of context menus will be allocated, and will never
>be freed, and (b) The attribute NAME of the SELECT won't be
>stored anywhere.
>
>INPUT tags with TYPE=SUBMIT are rendered to one GE of type
>GE_SUBMIT. The value of the attribute VALUE is stored on the "txt"
>field. The value of the ACTION attribute is stored on the field
>"arg". The field "a" will store HTA_SUBMIT.
>
>TD tags are rendered to one GE of type GE_RECT. The value of the
>BGCOLOR attribute is stored on the "bg" field as a code (only the
>colors known by the Clara GUI are supported: WHITE, BLACK, GRAY,
>DARKGRAY and VDGRAY). The coordianates of the cell within the table
>are stored on the fields "tr" and "tc".
>
>All other supported tags do not generate GEs.
>
>*/
